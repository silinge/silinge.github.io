@charset "utf-8";
/* CSS Document */

/*
.container {
	display: table;
	width: 100%;
}

.main {
	display: table-cell;
	width: 70%;
	background-color: aqua;
	border-radius: .5em;
}

.sidebar{
	display: table-cell;
	width: 30%;
	margin-left: 1.5em;
	padding: 1.5em;
	background-color: cadetblue;
	border-radius: .5em;
}*/

/*
.wrapper{
	margin-left: -1.5em;
	margin-right: -1.5em;
}

.container {
	display: table;
	width: 100%;
	border-spacing: 1.5em 0;
}
*/
/*

.main {
	display: table-cell;
	width: 70%;
	background-color: cornflowerblue;
	border-radius: .5em;
}

.sidebar {
	display: table-cell;
	width: 30%;
	padding: 1.5em;
	background-color: darkmagenta;
	border-radius: .5em;
}*/

/*
.container {
	display: flex;
}

.main {
	width: 70%;
	background-color: aquamarine;
	border-radius: 0.5em;
}

.sidebar {
	width: 30%;
	padding: 1.5em;
	margin-left: 1.5em;
	background-color: darkcyan;
	border-radius: .5em;
}
*/

/*
header {
	padding-top: 4em;
	padding-bottom: 4em;
	color: yellow;
	background-color: cyan;
	border-radius: .5em;
}*/

/*
header {
	padding: 1em 1.5em;
	color: black;
	background-color: wheat;
	border-radius: .5em;
}

.button-link {
	margin-top: 1.5em;
	display: block;
	padding: 0.5em;
	color: ghostwhite;
	background-color: #0090c9;
	text-align: center;
	text-decoration: none;
	text-transform: uppercase;
}
*/

/*只给紧跟在其他button-link后面的button-link加上顶部外边距*/
/*
.button-link + .button-link {
	margin-top: 1.5em;
}
*/
/*这个sponsor-link 会遭到adblock插件过滤，如果可以换别的名字，真是奇怪。*/
/*
.sponsor-link {
	display: block;
	color: #0072B0;
	font-weight: bold;
	text-decoration: none;
}
*/

/*猫头鹰选择器 * + *，它不会选中直接跟在其他按钮后面的按钮，而是会选中直接跟在其他元素后来的任何元素。 它会选中页面上有着相同父级的非第一个子元素。接下来用猫头鹰选择器给页面元素加上顶部外边距，这样就会给侧边栏的每一个元素加上一致的间距，给选择器还会选中主容器，因为它是头部的相邻兄弟节点。*/

/*将body放在选择器前面，这样该选择器就只能选中body内的元素，如果不加body,它还会选中body元素，因为它是head元素的相邻兄弟节点。*/


/*
body * + * {
	margin-top: 1.5em;
}
*/

/*猫头鹰选择器的顶部外边距对侧边栏有个副作用，因为侧边栏时主列的相邻兄弟元素，所有它也会有顶部外边距。因此要将其恢复为0，还需要给主列补上内边距。*/

/*

.main {
	width: 70%;
	padding: 1em 1.5em;
	background-color: #D78B10;
	border-radius: .5em;
}

.sidebar {
	width: 30%;
	padding: 1.5em;
	margin-top: 0;
	margin-left: 1.5em;
	background-color: #3EA208;
	border-radius: .5em;
}
*/

/*来一个最终版*/
/*
:root {
	box-sizing: border-box;
}

*,
::before,
::after {
	box-sizing: inherit;
}

body {
	background-color: #EEEEEE;
	font-family: helvetica, arial, sans-serif;
}

body * + * {
	margin-top: 1.5em;
}

header {
	padding: 1em 1.5em;
	color: #FFFFFF;
	background-color: #0072B0;
	border-radius: .5em;
}

.container {
	display: flex;
}

.main {
	width: 70%;
	padding: 1em 1.5em;
	background-color: #FFFFFF;
	border-radius: .5em;
}

.sidebar {
	width: 30%;
	padding: 1.5em;
	margin-top: 0;
	margin-left: 1.5em;
	background-color: #FFFFFF;
	border-radius: .5em;
	
}

.button-link {
	display: block;
	padding: .5em;
	color: #FFFFFF;
	background-color: #0090C9;
	text-align: center;
	text-decoration: none;
	text-transform: uppercase;
}

.sponsor-link {
	display: block;
	color: #0072b0;
	font-weight: bold;
	text-decoration: none;
}*/

/*浮动设计样式*/

/*
:root {
	box-sizing: border-box;
}

*,
::before,
::after {
	box-sizing: inherit;
}

body {
	background-color: #EEEEEE;
	font-family: helvetica, arial, sans-serif;
	
}

body * + * {
	margin-top: 1.5em;
}

header {
	padding: 1em 1.5em;
	color: #FFFFFF;
	background-color: #0072B0;
	border-radius: .5em;
	margin-bottom: 1.5em;
}

.main {
	padding: 0 1.5em;
	background-color: #FFFFFF;
	border-radius: .5em;
}

.container {
	max-width: 1080px;
	margin: 0 auto;
}

.media {
	float: left;
	width: 50%;
	padding: 1.5em;
	background-color: #09A099;
	border-radius: 0.5em;
}
*/

/*容器内浮动元素 不整齐需要处理。方法一 使用跟浮动配套的clear属性 将一个元素放在主容器末尾 并对它使用clear 它会让容器扩展到浮动元素下面 tu48代码*/

/*方法二使用伪元素 使用::after 伪元素选择器 可以快速在DOM中在容器末尾添加一个元素，而不用在HTML里添加标记 伪元素常见的有::before ::after 用来向元素的开始或者结束位置插入内容。*/

/*
.clearfix::after {
	display: block;
	content: " ";
	clear: both;
}
*/
/*将伪元素的display设置为非inline 并给定一个content值 以便让伪元素出现在文档中 让伪元素清楚容器中的所有浮动*/

/*修改清楚浮动的代码，让其包含所有的外边距 1让::before和 ::after伪元素都显示出来 2 防止伪元素的外边距折叠 3只有::after伪元素需要清除浮动*/

/*
.clearfix::before,
.clearfix::after {
	display: table;
	content: " ";
}

.clearfix::after {
	clear: both;
}
*/

/*三个左浮动的盒子 如果盒子1比盒子2高 则盒子3不会浮动到最左边，而是浮动到盒子1的右边 解决问题 清楚第三个浮动元素上面的浮动 更先进一点 清楚每行第一个元素上面的浮动。由于已知每行有两个盒子，因此只需要清除每行的第奇数个元素上面那行的浮动即可。 你可以用 nth-child()伪类选择器选中这些目标元素 如下*/
/*
.media {
	float: left;
	width: 50%;
	padding: 1.5em;
	background-color: #EEEEEE;
	border-radius: 0.5em;
}
*/
/*odd就是奇数*/
/*
.media:nth-children(odd) {
	clear: left;
}*/

/*如果每行需要三个元素 则 .media:nth-child(3n+1)来隔两个元素选一个元素*/

/*上面这种清除每行浮动的技术要求知道每行有几个元素，如果宽度不是通过百分比来定义的，那么随着视口宽度的改变，每行的元素个数可能会变化。这种情况最好使用别的布局方案，比如flexbox或者 inline-block元素。*/
/*
.media {
	float: left;
	margin: 0 1.5em 1.5em 0;
	width: calc(50% - 1.5em);
	padding: 1.5em;
	background-color: #CCCCCC;
	border-radius: 0.5em;
}
*/
/*给媒体元素加上右侧和底部的外边距，一行放不下两个元素，因此需要用calc() 从宽度里减去右外边距的值*/
/*
.media:nth-child(odd) {
	clear: left;
}
*/
/*图片在左边，文字在右边，不包围 设置图像左浮动*/
/*
.media-image {
	float: left;
}

.media-body {
	margin-top: 0;
}

.media-body h4 {
	margin-top: 0;
}
*/

/*建立块级格式化上下文，让文字不会跟浮动图片重叠 bfc是网页的一块区域，元素基于这块区域布局。虽然BFC本身是环绕文档流的一部分，但它将内部的内容与外部的上下文隔离开
包含内部所有元素的上下外边距 它们不会跟bfc外面的元素产生外边距折叠
包含内部所有浮动元素
不会跟bfc外面的浮动元素重叠。
如果给元素增加clear属性，它只会清除自身所在bfc内的浮动，如果强制给一个元素生成一个新的bfc 它不会跟其他bfc重叠

给元素添加以下的任意属性值都会创建bfc
float:left 或right 不为none即可
overflow:hidden auto scroll 不为visible即可
display:inline-block table-cell table-caption flex inline-flex grid inline-grid 拥有这些属性的元素称为块级容器

position:absolute position:fixed

网页的根元素也创建了一个顶级的BFC
*/

/*添加overflow:auto 创建一个新的bfc*/

/*
.media {
	float: left;
	margin: 0 1.5em 1.5em 0;
	width: calc(50% - 1.5em);
	padding: 1.5em;
	background-color: darkseagreen;
	border-radius: 0.5em;
}

.media:nth-child(odd) {
	clear: left;
}

.media-image {
	float: left;
	margin-right: 1.5em;
}

.media-body {
	overflow: auto;
	margin-top: 0;
}

.media-body h4 {
	margin-top: 0;
}*/

/*构建网格系统*/

/*
.row::after {
	content: " ";
	display: block;
	clear: both;
}
*/

/*这个选择器匹配所有类包含“column-” 的元素 这个属性选择器 根据元素的class属性匹配元素 */
/*
[class*="column-"] {
	float: left;
	padding: 0 0.75em;
	margin-top: 0;
}

.column-1 {width: 8.3333%;}
.column-2 {width: 16.6667%;}
.column-3 {width: 25%;}
.column-4 {width: 33.3333%;}
.column-5 {width: 41.6667%;}
.column-6 {width: 50%;}
.column-7 {width: 58.3333%;}
.column-8 {width: 66.6667%;}
.column-9 {width: 75%;}
.column-10 {width: 83.3333%;}
.column-11 {width: 91.6667%;}
.column-12 {width: 100%;}
*/

/*接下来媒体对象样式，去掉左浮动，因为网格系统已经包含这条规则。去掉宽度 这样它才能填满容器100%的宽度。这里的容器是一个6列的元素，它的宽度恰好是我们想要的。去掉外边距和用来清除浮动的nth-child选择器。*/

/*
.media {
	padding: 1.5em;
	background-color: #eee;
	border-radius: 0.5em;
}

.media-image {
	float: left;
	margin-right: 1.5em;
}

.media-body {
	overflow: auto;
	margin-top: 0;
}

.media-body h4 {
	margin-top: 0
}

.main {
	padding: 0 1.5em 1.5em;
	background-color: #FFFFFF;
	border-radius: .5em;
}
*/

/*在属性选择器补充 网格系统还缺少每列之间的间隔，现在加上。每个网格列添加左右内边距，创造间隔。把间隔交给网格系统实现，而不是让内部的组件自己实现。因为需要列之间有1.5em的间隔，所有可以将其分成两边，给每个列元素左右各添加一半的内边距。417 加在 [class*=*column-*]里面这里去掉所有列元素的顶部外边距，覆盖猫头鹰选择器里的样式规则*/

/*再给网格添加负的外边距*/
/*
.row {
	margin-left: -0.75em;
	margin-right: -0.75em;
}*/

/*来个完整的*/

/*
:root {
	box-sizing: border-box;
}

*,
::before,
::after {
	box-sizing: inherit;
}

body {
	background-color: #eee;
	font-family: helvetica, arial, sans-serif;
}

body * + * {
	margin-top: 1.5em;
}

.row {
	margin-left: -0.75em;
	margin-right: -0.75em;
}

.row::after {
	content: " ";
	display: block;
	clear: both;
}

[class*="column-"] {
	float: left;
	padding: 0 0.75em;
	margin-top: 0;
}

.column-1 {width: 8.3333%;}
.column-2 {width: 16.6667%;}
.column-3 {width: 25%;}
.column-4 {width: 33.3333%;}
.column-5 {width: 41.6667%;}
.column-6 {width: 50%;}
.column-7 {width: 58.3333%;}
.column-8 {width: 66.6667%;}
.column-9 {width: 75%;}
.column-10 {width: 83.3333%;}
.column-11 {width: 91.6667%;}
.column-12 {width: 100%;}

header {
	padding: 1em 1.5em;
	color: #fff;
	background-color: #0072b0;
	border-radius: .5em;
	margin-bottom: 1.5em;
}

.main {
	padding: 0 1.5em 1.5em;
	background-color: #fff;
	border-radius: .5em;
}

.comtainer {
	max-width: 1080px;
	margin: 0 auto;
}

.media {
	padding: 1.5em;
	background-color: #eee;
	border-radius: 0.5em;
}

.media-body {
	overflow: auto;
	margin-top: 0;
}

.media-body h4 {
	margin-top: 0;
}

.clearfix::before,
.clearfix::after {
	display: table;
	content: " ";
}

.clearfix::after {
	clear: both;
}*/

/*使用flexbox布局实现的网页*/

/*
:root {
	box-sizing: border-box;
}

*,
::before,
::after {
	box-sizing: inherit;
}

body {
	background-color: #709b90;
	font-family: helvetica, arial, sans-serif;
	
}

body * + * {
	margin-top: 1.5em;
}

.container {
	max-width: 1080px;
	margin: 0 auto;
}
*/

/*接下来分几步构建这个菜单，先给列表加上display:flex 然后覆盖浏览器默认的列表样式和猫头鹰选择器设置的顶部外边距，同时添加颜色。*/
/*	兼容性要求*/
/*
.site-nav {
	display: flex;

	display: -webkit-flex;
	display: -ms-flexbox;
	padding-left: 0;
	list-style-type: none;
	background-color: #5f4b44;
}

.site-nav > li {
	margin-top: 0;
}

.site-nav > li > a {
	background-color: #cc6b5a;
	color: white;
	text-decoration: none;
}
*/

/*这里应当把菜单项内边距加到内部的<a>元素上，而不是<li>元素上，因为整个点击区域的外观和行为应当都符合用户对一个菜单链接的预期。而链接行为来自<a>元素，所有如果把<li>做成一个好看的大按钮，里面只有很小的区域<a>可以点击，就不符合用户预期  给链接外的菜单容器添加内边距，让链接成为块级元素，这样就能撑开父元素的高度。 给链接添加内边距。*/
/*

.site {
	display: flex;
	padding: .5em;
	background-color: #5f4b33;
	list-style-type: none;
	border-radius: .2em;
}

.site-nav > li {
	margin-top: 0;
}

.site-nav > li > a {
	display: block;
	padding: .5em 1em;
	background-color: #cc6b5a;
	color: white;
	text-decoration: none;
}
*/

/*接下来给菜单项添加间隔，常规的外边距就能做到这一点，flexbox允许使用margin:auto来填充弹性子元素之间的可用空间。flexbox还允许将最后的菜单项移动到右侧，加上外边距后菜单就完成了。 使用外边距给弹性子元素加上间隔*/

/*选中所有前面列表项的列表项，也就是说除了第一项之外的所有列表项 弹性盒子内的auto外边距会填充所有可用空间*/

/*
.site-nav > li + li {
	margin-left: 1.5em;
}

.site-nav > .nav-right {
	margin-left: auto;
}
*/

/*将主容器设置为FLEXbox 给三个板块加上白色背景和内边距 将主容器设置为flexbox 去点顶部外边距 给每个弹性子元素之间加上间隔*/

/*
.title {
	padding: 1.5em;
	background-color: #fff;
}

.flex {
	display: flex;
}

.flex > * + * {
	margin-top: 0;
	margin-left: 1.5em;
}
*/

/*使用flex属性设置列宽*/

/*
.column-main {
	flex: 2;
}

.column-sidebar {
	flex: 1;
}
*/

/*
flex-grow:2;
flex-shrink:1;
flex-basis: 0%;
*/

/*flex属性是三个不同大小属性的简写：flex-grow flex-shrink flex-basis 上面提供flex-grow值 剩下的两个属性是默认值分别是1和0% 因此flex:2等价于flex:210%.通常首选简写属性 但也可以分别声明三个属性。*/

/*flex-basis定义了元素大小的基础值 即一个初始的主尺寸 属性可以设置为任意的width值 包括px em 百分比 它的初始值是auto，此时浏览器会检查是否设置了width属性值。如果有 则使用width的值作为flex-basis的值，如果没有 则用元素内容自身的大小 如果flex-basis的值不是auto,width属性会被忽略*/

/*每个弹性子元素的初始主尺寸确定后，它们可能需要在主轴方向扩大或者缩小来适应或者填充 弹性容器的大小。这时就需要flex-grow flex-shrink来决定缩放的规则*/

/*每个弹性子元素的flex-basis值计算出来后，他们加上子元素之间的外边距会占据一定的宽度。加起来的宽度不会正好填满弹性容器的宽度，可能会留白，多出来的留白或剩余宽度会按照flex-grow = 增长因子的值分配给每个弹性子元素，flex-grow的值为非负整数。如果元素的flex-grow值为0 那么它的宽度不会超过flex-basis的值；如果元素的增长因子非0 那么这些元素会增长到所有的剩余空间被分配完 也就意味着子元素会填满容器的宽度。 flew-grow:2 增长的宽度为flex-grow:1元素的两倍。*/

/*如果在flex中忽略某个子属性被省略，那么flex简写属性会给出有用的默认值 flex-grow:1 flex-shrink:1 flex-basis:0 默认值正是大多数情况所需要的值。 每个子元素flex-shrink值代表了它是否应该收缩以防止溢出。如果元素flex-shrink:0 则不会收缩，如果大于0则会收缩至不再溢出。按照flex-shrink值的比例 值越大收缩越多。用flex-shrink也能实现上述页面中两列的宽度。首先将两列的flex-basis指定为理想的比例= 66.67% 和33.33%。他们的宽度之和加上1.5em的间隔就会比容器宽度多出1.5em.然后将两列的flex-shrink设置为1，这样就会从每列的宽度减掉0.75em, 容器就能容纳两列了。*/

/*使用flex属性设置宽度 1 等价于 flex:1 1 66.67% 2-等价于flex:1 1 33.33%*/
/*
.column-main {
	flex: 66.67%;
}

.column-sidebar {
	flex: 33.33%;
}
*/

/*弹性方向 flex-direction:  row是默认值。column column-reverse row-reverse*/
/*要求右边栏的板块跟左边的大板块对齐。让两列扩展到填满容器的高度，因此将右边栏改为弹性容器并设置flex-direction:column 然后给里面的两个板块设置非0的flex值*/
/*在右侧创建一个弹性列  对外面的弹性盒子来说是弹性子元素 对内部元素而言是弹性容器。 2 给内部子元素加上flex-grow*/
/*
.column-sidebar {
	flex: 1;
	display: flex;
	flex-direction: column;
}

.column-sidebar > .tile {
	flex: 1;
}
*/

/*<form> 的类名为login-form 在CSS中用作表单的选择器。下面代码分别给登录表单的标题，输入区域 按钮布局。1 标题设置为加粗 右对齐 全大写。2 给文本类型的输入框（不包含复选框和单选按钮）添加样式。3 给按钮添加样式。*/

/*
.login-form h3 {
	margin: 0;
	font-size: .9em;
	font-weight: bold;
	text-align: right;
	text-transform: uppercase;
}

.login-form input:not([type=chechbox]):not([type=radio]) {
	display: block;
	width: 100%;
	margin-top: 0;
}
*/
/*分析 not()伪类和属性选择器[type=checkbox] [type=radio] 可以选中出来复选框和单选按钮以为的所有<input>元素。这是一个黑名单方式 把不想选中的元素排除，还有白名单方式 把想要选中的属性都列出来，权衡一下属性多少再用黑白。*/

/*
.login-form button {
	margin-top: 1em;
	border: 1px solid #cc6b5a;
	background-color: white;
	padding: .5em 1em;
	cursor: pointer;
}
*/

/*如果弹性容器开启了flex-wrap 则会忽略该属性 flex-shrink.。align-self 控制子元素在副轴上的对齐方式。它会覆盖容器上的align-items值。如果子元素副轴方向上的外边距为auto 则会忽略该属性 order整数 将弹性子元素从兄弟节点中移动到指定位置 覆盖源码顺序。*/

/*flex-wrap属性允许弹性子元素换到新的一行或多行显示。它可以设置nowrap初始值，wrap 或wrap-reverse. 启用换行后 子元素不再根据flex-shrink值收缩，任何超过弹性容器的子元素都会换行显示。 如果弹性方向是column或column-reverse 那么flex-wrap会允许弹性子元素换到新的一列显示，不过这只在限制了容器高度的情况下才会发生，否则容器会扩展高度以包含全部弹性子元素。*/

/*flex-flow 属性 是flex-direction 和flex-wrap的简写 例如 flex-grow:column  wrap指定弹性子元素按照从上到下的方式排列 必要时换到新的一列。*/

/*justify-content属性 当子元素为填满容器时，justify-content属性控制子元素沿主轴方向的间距。它的值包括几个关键字 flex-start、flex-end center space-between space-around。默认值flex-start让子元素从主轴的开始位置顺序排列，比如主轴方向为从左到右的话 开始位置就是左边。如果不设置外边距，那么子元素之间不会产生间距。如果值为flex-end 子元素就从主轴的结束位置开始排列 center的话则让子元素居中。 值space-between将第一个弹性子元素放在主轴开始的地方 最后一个子元素放在主轴结束的地方 剩下的子元素间隔均匀地放在这两者之间的区域。值space-around类似 只不过给第一个子元素的前面和最后一个子元素的后面也加上相同的间距 间距时在元素的外边距之后进行计算的，而且flex-grow的值要考虑进来。如果任意子元素的flex-grow的值不为0 或者任意子元素在主轴方向的外边距值为auto, justify-content就失效了。*/

/*align-items属性 justify-content属性控制子元素在主轴方向的对齐方式，align-items则控制子元素在副轴方向的对齐方式。align-items的初始值为stretch 在水平排列的情况下让所有子元素填充容器的宽度，在垂直排列的情况下让子元素填充容器的宽度，  因此它能实现登高列。  其他的值让弹性子元素可以保留自身的大小 而不是填充容器的大小 类似的概念有vertical-align  flex-start flex-end让子元素与副轴的开始或结束位置对齐（如果时水平布局的话，则与容器的顶部或者底部分别对齐）。 center让元素居中 baseline让元素根据每个弹性子元素的第一行文学的基线对齐 当你想要一个弹性子元素里大字号标题的基线与其他弹性子元素里较小文字的基线对齐时，baseline就能派上用场。*/

/*justify-content 和 align-items属性 调整让其在水平方向的两端之间均匀分布，而align-items更新vertical-align 让行内元素在垂直方向对齐。*/

/*align-content属性 如果开启了换行（用flex-wrap） align-content属性就可以控制弹性容器内沿副轴方向每行之间的间距。它支持的值有flex-start flex-end center stretch space-between space-around 这些值对间距的出来类似上面justify-content*/

/* align-self属性，控制弹性子元素沿着容器副轴方向的对齐方式，它跟弹性容器的align-items属性效果相同，但是它能单独给弹性子元素设定不同的对齐方式。auto为初始值 会以容器的align-items值为准。其他值会覆盖容器的设置。align-self属性支持的关键字和align-items一样；flex-start flex-end center stretch以及baseline */

/* order属性 使用它能改变子元素排列的顺序，还可以将其指定为任意正负整数 如果多个弹性子元素有一样的值，它们就会按照源码顺序出现。初始状态下所有的弹性子元素的order都为0 指定一个元素的值为-1 它就会移动到列表的最前面，指定为1则会移动到最后。如果按照需要给每个子元素指定order一遍重新编排它们，这些值不一定要连续。 */
/* 使用对齐属性完成一个样式价格和行动召唤按钮。 */

/*
.centerd {
	text-align: center;
}

.cost {
	display: flex;
	justify-content: center;
	align-items: center;
	line-height: .7;
}

.cost > span {
	margin-top: 0;
}

.cost-currency {
	font-size: 2rem;
}

.cost-dollars {
	font-size: 4rem;
}

.cost-cents {
	font-size: 1.5rem;
	align-self: flex-start;
}

.cta-button {
	display: block;
	background-color: #cc6b5a;
	color: white;
	padding: .5em 1em;
	text-decoration: none;
}
*/

/*网格容器 跟flexbox类似 网格布局也是作用于两级的dom结构 设置为display:grid的元素成为一个网格容器 它的子元素则变成网格元素*/

/*
.grid {
	display: grid;
	grid-template-columns: 1fr 1fr 1fr;
	grid-template-rows: 1fr 1fr;
	grid-gap: 0.5em;
}

.grid > * {
	background-color: darkgray;
	color: white;
	padding: 2em;
	border-radius: 0.5em;
}
*/

/*使用display:grid定义一个网格容器，容器会表现得像一个块级元素，100%填充可以宽度。也可以用inline-grid 这样元素就会在行内流动，且宽度只能够包含子元素 不过inline-grid的使用频率不高。 新属性 grid-template-columns 和 grid-template-rows 它们定义网格每行每列的大小 使用新单位fr 代表每一行的分数单位 这个单位跟flexbox中 flex-grow因子的表现一样，grid-template-columns:1fr 1fr 1fr表示三列等宽。 还可以使用其他单位 px, em 或 百分数 也可以混搭 例子 grid-template-columns:300px 1fr 定义了一个固定宽度的300px的列 后面跟着一个会填满剩余可以空间的列 2fr的列宽是1fr的两倍。最后grid-gap属性定义了每个网格单元之间的间距，以可以用两个值分别指定垂直和水平方向的间距 比如 grid-gap:0.5em 1em;*/

/*网格剖析 网格线 构成了网格的框架 一条网格线可以水平或垂直 也可以位于一行或一列的任意一侧 如果指定了grid-gap的话 它就位于网格线上。还有网格轨道 网格单元 网格区域*/

/*一个网格布局的HTML结构*/

/*
:root {
	box-sizing: border-box;
}

*,
::before,
::after {
	box-sizing: inherit;
}

body {
	background-color: #709b90;
	font-family: helvetica, arial, sans-serif;
}
*/

/*定义两个垂直的网格轨道 定义四个水平轨道 大小为auto*/
/*
.container {
	display: grid;
	grid-template-columns: 2fr 1fr;
	grid-template-rows: repeat(4, auto); 
	grid-gap: 1.5em;
	max-width: 1080px;
	margin: 0 auto;
}
*/

/*从1号垂直网格线跨越到3号垂直网格线 2/刚好占据一条水平网格轨道*/
/*
header,
nav {
	grid-column: 1 / 3;
	grid-row: span 1;
}
*/

/*将其他网格元素定位到不同的网格线之间*/

/*
.main {
	grid-column: 1 / 2;
	grid-row: 3 / 5;
}

.sidebar-top {
	grid-column: 2 / 3;
	grid-row: 3 / 4;
}

.sidebar-bottom {
	grid-column: 2 / 3;
	grid-row: 4 / 5;
}
*/

/*
.tile {
	padding: 1.5em;
	background-color: #fff;
}

.tile > :first-child {
	margin-top: 0;
}

.tile * + * {
	margin-top: 1.5em;
}
*/

/*代码首先设置网格容器，并用grid-template-columns和grid-template-rows定义网格轨道，因为列的分数单位分别是2fr 1fr所有第一列的宽度是第二列的两倍，定义行的时候用到了新方法 repeat()函数 它在声明多个网格轨道的时候提供了简写方式。 grid-template-rows:repeat(4, auto);定义四个水平网格轨道 高度为auto,这等价于grid-template-rows:auto auto auto auto; 轨道大小设置为auto 轨道会根据自身内容扩展。 用repeat()符号还可以定义不同的重复模式 比如repeat(3, 2fr 1fr) 会重复三遍这个模式 从而定义六个网格轨道 重复的结果是2fr 1fr 2fr 1fr 2fr 1fr. 还可以将repeat()作为一个更长模式的一部分 比如grid-template-columns: 1fr repeat(3, 3fr) 定义一个1fr的列 接着是三个3fr的列。 可以在grid-column和grid-row属性中用网格线的编号指定网格元素的位置，如果想要一个网络元素在垂直方向上跨越1号网格线到3号网格线，就需要给元素设置grid-column:1 / 3.或者设置grid-row:3 / 5让元素在水平方向上跨越3号网格线到5号网格线  grid-column是grid-column-start和grid-column-end的简写 grid-row也是这样。中间的斜线只在简写属性里用于区分两个值，斜线前后的空格不做要求。*/
/*

定位header和nav的规则集稍有变化 以下代码片段用相同的规则集同时布局这两者
header,
nav {
	grid-column: 1 / 3;
	grid-row: span 1;
}
span关键字告诉浏览器元素需要占用一个网格轨道，因为这里没有支持具体是哪一行 所有会根据网格元素的布局算法自动将其放到合适的位置 布局算法会将元素放在网格上可以容纳该元素的第一处可用空间，本例中是第一行和第二行。
*/
/*剩余的网页样式*/
/*
.page-heading {
	margin: 0;
}

.site-nav {
	display: flex;
	margin: 0;
	padding: .5em;
	background-color: #5f4b44;
	list-style-type: none;
	border-radius: .2em;
}

.site-nav > li {
	margin-top: 0;
}

.site-nav > li > a {
	display: block;
	padding: .5em 1em;
	background-color: #cc6b5a;
	color: white;
	text-decoration: none;
}

.site-nav > li + li {
	margin-left: 1.5em;
}

.site-nav > .nav-right {
	margin-left: auto;
}

.login-form h3 {
	margin: 0;
	font-size: .9em;
	font-weight: bold;
	text-align: right;
	text-decoration: uppercase;
}

.login-form input:not([type=checkbox]):not([type=radio]) {
	display: block;
	margin-top: 0;
	width: 100%;
}

.login-form button {
	margin-top: 1em;
	border: 1px solid #cc6b5a;
	background-color: white;
	padding: .5em 1em;
	cursor: pointer;
}

.centered {
	text-align: center;
}

.cost {
	display: flex;
	justify-content: center;
	align-items: center;
	line-height: .7;
}

.cost > span {
	margin-top: 0;
}

.cost-currency {
	font-size: 2rem;
}

.cost-dollars {
	font-size: 4rem;
}

.cost-cents {
	font-size: 1.5rem;
	align-self: flex-start;
}

.cta-button {
	display: block;
	background-color: #cc6b5a;
	color: white;
	padding: .5em 1em;
	text-decoration: none;
}
*/

/*
命名的网格线 有时候记录所有网格线的编号实在太麻烦 尤其是在处理很多网格轨道时。为了简单点，可以给网格线命名，并在布局时使用网格线的名称而不是编号，声明网格轨道时可以在括号内写上网格线的名称。如下
grid-template-column: [start] 2fr [center] 1fr [end];
这条声明定义了两列的网格，三天垂直的网格线分别叫作 start center end 之后定义网格元素在网格中的位置 可以不用编号而是用这些名称来声明 如下

grid-column: start / center;
这条声明将网格元素放在1号网格线start到2号网格线center之间的区域。还可以给同一个网格线提供多个名称比如下面的声明（为了可读性 这里将代码换行）
grid-template-columns:[left-start] 2fr [left-end right-start] 1fr [right-end];
在这条声明里，2号网格线既叫做left-end 也叫作right-start,之后可以任选一个名称使用。这里还有一个彩蛋;将网格线命名为left-start和left-end 就定义了一个叫作left的区域，这个区域覆盖两个网格线之间的区域。-start 和 -end后缀作为关键字，定义了两种之间的区域。如果给元素设置grid-column: left, 它就会跨越从left-start到left-end的区域。
*/

/*
.container {
	display: grid;
	grid-template-columns: [left-start] 2fr [left-end right-start] 1fr [right-end];
	grid-template-rows: repeat(4, [row] auto);
	grid-gap: 1.5em;
	max-width: 1080px;
	margin: 0 auto;
}
*/

/*给每个垂直的网格线命名，将水平网格线命名为"row"*/

/*
header,
nav {
	grid-column: left-start / right-end;
	grid-row: span 1;
}

.main {
	grid-column: left;
	grid-row: row 3 / span 2;
}
*/

/*跨越left-start到left-end之间的区域 从第三行网格线开始放置元素，跨越两个网格轨道*/
/*
.sidebar-top {
	grid-column: right;
	grid-row: 3 / 4;
}

.sidebar-bottom {
	grid-column: right;
	grid-row: 4 / 5;
}
*/

/*跨越right-start到right-end的区域*/

/*图6-10将网格元素放在第二个col网格线处，跨越两个轨道 col 2 / span 2) 这个场景展示了一种重复的模式 每两个网格列为一组，在每组的两个网格轨道之前命名一条网格线（grid-template-columns: repeat(3, [col] 1fr 1fr),然后就可以借助命名的网格线将一个元素定位到第二组网格列上 (grid-column: col 2 / span 2)*/

/*另一个时命名网格区域 不用计算或者命名网格线，直接用命名的网格区域将元素定位到网格中。实现这一方法需要借助网格容器的grid-template属性和网格元素的grid-area属性。*/

/*
.container {
	display:grid;
	grid-template-areas: "title title"
						"nav nav"
						"main aside1"
						"main aside2";
	grid-template-columns: 2fr 1fr;
	grid-template-rows: repeat(4, auto);
	grid-gap: 1.5em;
	max-width: 1080px;
	margin: 0 auto;
}
*/
/*将每个网格单元分配到一个命名的网格区域中 跟之前一样定义网络轨道的大小。*/

/*
header {
	grid-area: title;
}

nav {
	grid-area: nav;
}

.main {
	grid-area: main;
}

.sidebar-top {
	grid-area: aside1;
}

.sidebar-bottom {
	grid-area: aside2;
}
*/

/*将每个网格元素放到一个命名的网格区域
grid-template-areas 属性使用了一种ASCII art的语法，可以直接再CSS中画一个可视化的网格形象。该声明给出了一些列加引号字符串，每一个字符串代表网络的一行，字符串内用空格区分每一列。 在这个例子中，第一行完全分配给了网格区域title 第二行则分配给了nav.接下来两行的左列分配给了main，侧边栏的板块分别分配给了aside1 和aside2。用grid-area属性将每个网格元素放在这些命名区域中。 每个命名的网格区域必须组成一个矩形，不能创造更复杂的形状。还可以用句点.作为名称，这样便能空出一个网格单元 比如；
grid-template-areas:*top top right*
					*left .  right*
					*left bottom bottom*;
这样中间围了一个空的网格单元。
*/

/*图片墙 代码清单6-9 它使用grid-auto-rows为所有的隐式网格行指定一个1fr的大小，每一行拥有相同的高度。该布局还引入两个新概念。auto-fill 和 minmax()函数*/

/*
body {
	background-color: #709b90;
	font-family: helvetica, arial, sans-serif;
}

.protfolio {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
	grid-auto-rows: 1fr;
	grid-gap: 1em;
}

.portfolio > figure {
	margin: 0;
}

.portfolio img {
	max-width: 100%;
}

.portfolio figcaption {
	padding: 0.3em 0.8em;
	background-color: rgba(0, 0, 0, 0.5);
	color: #fff;
	text-align: right;
}
*/
/*有时候我们不想给一个网格轨道设置固定尺寸，但是又希望限制它的最小值和最大值。这时候需要用minmax()函数 它指定两个值:最小尺寸和最大尺寸。浏览器会确保网格轨道的大小介于这两者之间。如果最大尺寸小于最小尺寸 最大尺寸就会被忽略。通过指定minmax(200px, 1fr) 浏览器确保了所有的轨道至少宽200px.

repeat()函数里的auto-fill关键字是一个特殊值。设置了之后 只要网格放得下，浏览器就会尽可能多地生成轨道，并且不会跟指定大小(minmax()) 的限制产生冲突。

auto-fill 和 minmax(200px, 1fr) 加在一起 就会让网格在可用的空间内尽可能多地产生网格列，并且每个列的宽度不会小于200px 因为所有轨道的大小上限都为1fr（最大值） 所以所有的网格轨道都等宽。

如果网格元素不够填满所有网格轨道 auto-fill就会导致一些空的网格轨道，如果不希望出现空的网格轨道 可用使用auto-fit关键字代替auto-fill 它会让非空的网格轨道扩展 填满可用空间。

网格布局模块规范提供了另一个属性grid-auto-flow 它可以控制布局算法的行为，它的初始值是row 如果值为column 它就会将元素优先放在网格列中 只有当一列填满了 才会移动到下一行。 还可以额外加一个关键字dense (grid-auto-flow:column dense )它让算法紧凑地填满网格里的空白，尽管这会改变某些网格元素的顺序。加上这个关键字 小元素就会回填大元素造成的空白区域

加上紧凑的auto-flow选项dense 小网格元素会填满大的元素造成的空白区域。
610放大特定图片*/ 
/*
.portfolio {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
	grid-auto-rows: 1fr;
	grid-gap: 1em;
	grid-auto-flow: dense;
}

.portfolio .featured {
	grid-row: span 2;
	grid-column: span 2;
}
*/

/*这段代码使用grid-auto-flow:dense 等价于grid-auto-flow:row dense 前面的写法隐含了row 因为初始值就是row 然后选中特定的图片将其设置为在水平和垂直方向上各占据两个网格轨道 注意 本例只用了span关键字 没有明确地将任何一个网格元素放到某个网格轨道上 这样布局算法就会将网格元素放到它觉得合适的地方。*/

/*默认情况下 每个网格元素都会扩展并填满整个网格区域 但是子元素不会 因此网格区域出现了多余的高度 一个简单的解决方法是用flexbox 设置每个<figure>为弹性容器 方向为column 元素会从上到下垂直排列 然后给图片标签加上flex-grow 强制拉伸图片填充空白区域
但是拉伸图片并不可取 因为这会改变图片的宽高比 导致图片变形 好在css为控制这一行为提供了一个特殊属性object-fit 默认情况 一个<img>的object-fit属性值为fill, 也就是整个图片会缩放 以填满<img>元素。object-fit属性的值还可以是cover和contain 这些值告诉浏览器 在渲染盒子里改变图片的大小 但是不要让图片变形。
cover 扩展图片让它填满盒子 导致图片一部分被裁剪
contain 缩放图片 让它完整地填充盒子 导致盒子里出现空白。

用flex-grow属性拉伸了图片 所有应该给它加上object-fit:cover防止渲染的图片变形 作为妥协 图片的边缘会被裁掉一部分。代码611
*/

/*
.portfolio > figure {
	display: flex;
	flex-direction: column;
	margin: 0;
}

.portfolio img {
	flex: 1;
	object-fit: cover;
	max-width: 100%;
}
*/
/*让每个网格元素都成为垂直的flexbox 用弹性拉伸 让图片填充弹性容器的可用空间。让渲染的图片填充盒子并且不被拉伸 而是裁掉边缘。*/
/*特性查询 如果浏览器不支持网格布局，并给出回退样式 css最近添加了一个叫做特性查询的功能 该功能有助于解决整个问题
@supports (display:grid) {
	...
}

@supports规则后面跟着一个小括号包围的声明 如果浏览器理解这个声明 它就会使用大括号里面的所有样式规则 如果它不理解小括号里面的声明 它就不会使用这些样式规则。 就是说可以提供一份样式规则 它使用较旧的布局技术，比如浮动。这些样式不一定完美需要做出妥协，但是能实现基本的布局。然后在特性查询中 用网格补全剩下的样式。

以照片墙为例 可以用inline-block元素给旧版的浏览器提供一个较基础的布局 然后将所有网格布局相关的代码放到特性查询里，不支持网格的浏览器就会渲染成一块块大小一样的图片块。这个布局做了一些妥协 特定图片没有更大尺寸 每列的宽度固定为300px 而不是拉伸到填满可以的屏幕宽度 因为figure元素展示为inline-block 所以会正式换行 而且当屏幕够大的时候 一行就能放下更多图片。
612用特性查询实现渐进增强
*/

/*
.portfolio > figure {
	display: inline-block;
	max-width: 300px;
	margin: 0;
}

.portfolio img {
	max-width: 100%;
	object-fit: cover;
}

.portfolio figcaption {
	padding: 0.3em 0.8em;
	background-color: rgba(0,0,0,0.5);
	color: #FFFFFF;
	text-align: right;
}

@supports (display:grid) {
	.portfolio {
		display: gird;
		grid-template-columns: repeat(auto-fill), minmax(200px, 1fr);
		grid-auto-rows: 1fr;
		grid-gap: 1em;
		grid-auto-flow: dense;
	}
	
	.portfolio > figure {
		display: flex;
		flex-direction: column;
		max-width: initial;
	}
	.portfolio img {
		flex: 1;
	}
	.portfolio .featured {
		grid-row: span 2;
		grid-column: span 2;
	}
}
*/

/*回退代码和其他基础样式放在了特性查询外面，因此它们始终使用。如果用不支持网格的浏览器打开这个网页 就能看到619回退布局，所有跟网格相关的布局样式都在特性查询里，只有当浏览器支持网络时它们才会生效。
@supports 规则可以用来查询所有的css特性。比如 用@supports(display:flex)来查询是否支持flexbox 用@supports(mix-blend-mode:overlay)来查询是否支持混合模式
warning ie不支持@supports规则 它忽略了特性查询里的任何规则。不管是否真的支持该特性。
还有几种用法
@supports not(<declaration>) 只有当不支持查询声明里的特性时才使用里面的样式规则。
@supports(<declaration>) or (<declaration>) 查询声明里的两个特性只要有一个支持就是用里面的样式规则。
@supports(<declaration>) and (<declaration>)查询声明里的两个特性都支持才使用里面的样式规则。
这些写法还可以结合起来查询更复杂的情况，关键字or适合查询带浏览器前缀的属性
@supports(display:grid) or (display:-ms-grid)

css给网格布局提供了三个调整属性 justify-content justify-items justify-self 控制网格元素在水平方向上的位置 就像在文字处理器里调整文字位置。还有三个对齐属性 align-content align-items align-self 控制网格元素在垂直方向上的位置。就像表格布局里的vertical-align属性。
.grid {
display:grid;
height:1200px;
grid-template-rows:repeat(4, 200px);
}
它明确指定了网格容器的高度为1200px 但是只定义了高800px的有效水平网格轨道。align-content属性指定了网格轨道如何在剩下的400px空间内分布。它可以设为以下值
start将网格轨道放到网格容器的上/左 flexbox里面则是flex-start
end 将网格轨道放在网格容器的下/右 flexbox里面则是flex-end
center放中间
stretch将网格轨道拉伸至填满网格容器
space-between将剩余空间平均分配到每个网格轨道之间 它能覆盖任何grid-gap值。
space-around 将空间分配到每个网格轨道之间 且在两端各加上一半的间距
space-evenly 讲空间分配到每个网格轨道之间 且在两端各加上同等大小的间距 flexbox规范不支持。

*/
/*创建一个模态框盒子，添加模态框样式。*/

/*
body {
	font-family: helvetica, arial, sans-serif;
	min-height: 200vh;
	margin: 0;
}

button {
	padding: 0.5em 0.7em;
	border: 1px solid #8d8d8d;
	background-color: white;
	font-size: 1em;
}

.top-banner {
	padding: 1em 0;
	background-color: #ffd698;
}

.top-benner-inner {
	width: 80%;
	max-width: 1000px;
	margin: 0 auto;
}

.modal {
	display: none;
}

.modal-backdrop {
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	background-color: rgba(0,0,0,0.5);
}

.modal-body {
	position: fixed;
	top: 3em;
	bottom: 3em;
	right: 20%;
	left: 20%;
	padding: 2em 3em;
	background-color: white;
	overflow: auto;
}

.modal-close {
	cursor: pointer;
}
*/

/*这段css里 我们使用了两次固定定位 第一次时modal-backdrop 四个方向都设置为0 这让蒙层填满整个视口。它还有一个背景色rgba(0,0,0,0.5) 黑色半透明。因此该元素下面的所有网页内容就会变暗。第二次固定定位了modal-body 它的四条边都在视口内：顶边和底边到视口对应的边缘为3em,左边和右边距离视口对于的边缘为20%。因为它的背景色为白色，所以模态框呈现为一个在屏幕居中的白色盒子。虽然可以随意滚动网页 但是背景和模态框主体都不会动。

打开页面 我们看到屏幕上方有一个带按钮的淡黄色顶部条，点击按钮打开定位的模态框。因为是固定定位，所以即使滚动页面 模态框的位置也不会变。

控制定位元素的大小，定位一个元素时 不要求指定四个方向的值，可以只指定需要的方向值 然后用width和 /或height来决定它的大小。也可以让元素本身来决定大小。以下，
position: fixed;
top: 1em;
right: 1em;
width: 20%;
这段代码会将元素放在距离视口顶部和右边1em的位置，宽度为视口宽度的20%。它省略了bottom和height属性，元素的高度由自身的内容决定。例如 这可以用于将一个导航菜单固定到屏幕上。即使用户滚动网页内容，该元素的位置也不会改变。
因为固定元素从文档流中移除了 所以它不再影响页面其他元素的位置。别的元素会跟随正常文档流，就像固定元素不存在一样。

绝对定位 固定定位让元素相对视口定位，此时视口被称作元素的包含块。声明left:2em则将定位元素的左边放在距包含块左侧2em处。
绝对定位的行为也是如此，至少它的包含块不一样，绝对定位不是相对视口，而是相对最近的祖先定位元素。跟固定元素一样，属性top right bottom 和left决定了元素的边缘在包含块里的位置。

让close按钮绝对定位，我们需要将close按钮设置为绝对定位 因为它的父元素modal-body是固定定位 所以会成为close按钮的包含块。以下，

*/
/*
.modal-close {
	position: absolute;
	top: 0.3em;
	right: 0.3em;
	padding: 0.3em;
	cursor: pointer;
}
*/

/*这段代码将按钮放在距离modal-body顶部0.3em, 右侧0.3em的位置。如本例 包含块是元素的父元素 如果父元素未被定位，那么浏览器会沿着DOM树往上找它的祖父，曾祖父，直到找到一个定位元素 用它作为包含块。

close按钮已经定位好了，只是过于简陋。流行的是把close换成x,但是这会导致可访问性的问题：辅助的屏幕阅读器会读按钮里的文字。因此要给这个按钮一些有意义的提示，在使用css之前，HTML本身必须有意义。

相反 可以用css隐藏close 并显示x 需要两步，先将按钮的文字挤到外面，并隐藏溢出内容。然后将按钮的::after伪元素的content属性设置为x 并让伪元素绝对定位到按钮中间。代码74 使用unicode里面的乘法符号 比字母x更对称 好看。html字符 &times 可以显示为这个字符，但是css的content属性里 必须写成转义Unicode数字：\00D7.*/

/*
.modal-close {
	position: absolute;
	top: 0.3em;
	right: 0.3em;
	padding: 0.3em;
	cursor: pointer;
	font-size: 2em;
	height: 1em;
	width: 1em;
	text-indent: 10em;
	overflow: hidden;
	border: 0;
}

.modal-close::after {
	position: absolute;
	line-height: 0.5;
	top: 0.2em;
	left: 0.1em;
	text-indent: 0;
	content: "\00D7";
}
*/

/*以上代码指定按钮为1em大小的方形。text-indent属性将文字推到右边，溢出元素。它的确切值不重要，只要大于按钮宽度即可。由于text-indent是继承属性，需要在伪类元素选择器上设为0 因此x便不会缩进。

伪类元素现在是绝对定位，因为它表现得像按钮的子元素一样，所以定位的按钮成为其伪元素的包含块。设置一个较小的line-height让伪元素不要太高，用top和left属性让它在按钮中间定位。这里的精确值是我反复试出来的，建议你在自己的浏览器开发者工具里试试 看看它们如何影响定位。

绝对定位是定位类型里的重量级选手 它经常跟javascript配合 用于弹出菜单 工具提示以及消息盒子。我们将用绝对定位来构建一个下拉菜单 但在此之前 我们需要先看看它的搭档 相对定位。

当第一次给元素加上position:relative的时候，你通常看不到页面上有任何视觉改变。相对定位的元素以及它周围的所有元素 都还保持着原来的位置。

如果加上top right bottom 和left属性， 元素就会从原来的位置移走 但是不会改变它周围任何元素的位置
设置top:1em 将元素从原来的顶部边缘向下移动了1em; 设置left:2em将元素从它来的左侧边缘向右移动了2em 这可能导致元素跟它下面或者旁边的元素重叠 在定位中也可以使用负值 比如bottom: -1em也可以像top: 1em那样将元素向下移动1em.*/

/*创建一个下拉菜单75 该菜单的标记将它添加到html中 放在<div class="modal">的结束标签</div>后面。这段代码包含了一个容器元素，之后我们会将它的内容居中 并让它跟顶部条的内容对齐。弹出列表下面还放一个<h1>的标签 以展示弹出列表如何出现其他网页内容前面。

下拉菜单容器包含两个子元素 一个始终显示的灰色矩形标签以及一个下拉菜单 下拉菜单用显示和隐藏表示菜单展开和收起。因为它会是绝对定位 所以当下拉菜单显示时不会改变网页的布局，这意味着它显示时会出现其他内容前面。 接下来给下拉菜单加上相对定位。这样会给绝对定位的菜单创建一个包含块 代码76*/

/*
.container {
	width: 80%;
	max-width: 1000px;
	margin: 1em auto;
	
}

.dropdown {
	display: inline-block;
	position: relative;
}

.dropdown-label {
	padding: .5em 1.5em;
	border: 1px solid #ccc;
	background-color: #eee;
}

.dropdown-menu {
	display: none;
	position: absolute;
	left: 0;
	top: 2.1em;
	min-width: 100%;
	background-color: #eee;
}

.dropdown:hover .dropdown-menu {
	display: block;
}

.submenu {
	padding-left: 0;
	margin: 0;
	list-style-type: none;
	border: 1px solid #999;
}

.submenu > li + li {
	border-top: 1px solid #999;
	
}

.submenu > li > a {
	display: block;
	padding: .5em 1.5em;
	background-color: #eee;
	color: #369;
	text-decoration: none;
}

.submenu > li > a:hover {
	background-color: #fff;
}
*/
/*当鼠标指针移动到主菜单标签时，下拉菜单就会从下面弹出 这里是在整个容器上设置:hover 状态来打开菜单 也就是说 只要鼠标停在它的任何内容上，无论是dropdown-label 还是dropdown-menu 菜单都会保持打开状态。

当移动鼠标指针到主菜单标签时，下拉菜单就会从下面弹出 这里是在整个容器上设置:hover 状态来打开菜单。也就是说只要鼠标停在它的任何内容上，无论是dropdown-label还是dropdown-menu 菜单都会保持打开状态。

绝对定位的dropdown-menu设置了left:0 让其左边和整个容器的左侧对齐。然后它使用top:2.1em 将其顶部边缘放在标签下面 （算上内边距和边框，标签高2.1em).min-width为100% 保证它至少等于容器的宽度（容器宽度由dropdown-label决定。）之后用submenu类给下来菜单内的菜单加上样式。

如果现在打开模态框 你就会发现它以一种奇怪的方式位于下拉菜单后面 之后会解决。*/

/*用户鼠标悬停的时候用了一个:hover伪类打开菜单 通常更稳健的方式是使用Javascript添加和移除一个控制菜单开关的类名。这样就能在打开和关闭菜单之前添加适当的延迟 防止用户在鼠标快速滑过时无意间触发:hover 整个例子用鼠标能正常生效，但是触屏设备上会无效 只有一部分触屏设备会在轻触的时候触发:hover状态。该例子也没有解决用屏幕阅读器或者用键盘切换时的可访问性问题。更严谨的做法是增强下拉菜单的功能，确保能用触屏控制，并且当用户使用tab键切换菜单项的时候保持菜单打开。*/

/*创建一个CSS三角形

下拉菜单距离完美还差一步 现在它已能正常工作，但用户无法一眼察觉到主菜单标签下面还有更多内容。我们来给标签加上一个小的向下箭头 我们可以用边框画一个三角形当作向下箭头，这里用标签的::after伪元素来画三角形，然后使用绝对定位将它放到标签的右边。 思路 边框足够宽 会挤出4个三角形，其中三个设置为透明，可以显示一个向下的三角形  给dropdown-label::after伪元素加上样式，做一个三角形 并让它绝对定位代码77*/

/*
.dropdown-label {
	padding: 0.5em 2em 0.5em 1.5em;
	border: 1px solid #ccc;
	background-color: #EEEEEE;
}

.dropdown-label::after {
	content: "";
	position: absolute;
	right: 1em;
	top: 1em;
	border: 0.3em solid;
	border-color: black transparent transparent;
}

.dropdown:hover .dropdown-label::after {
	top: 0.7em;
	border-color: transparent transparent black;
}
*/

/*伪元素因为没有内容 所以没有宽或高。然后用border-color简写属性设置上边框为黑色 左右和下面的边框为透明 构造一个向下的箭头。dropdown-label右边用内边距留出了空间，用来放三角形。打开菜单 箭头方向反转 朝向上面，表示菜单可以被关闭。微调top值(从1em到0.7em) 让向上的箭头看起来跟向下的箭头处于相同的位置。

模态框和下拉菜单都会出现在静态内容之前，但是源码后面出现的元素会绘制在先出现的元素之前。解决这个问题的一个办法是在源码里将<div class="modal"> 及其内容移到下拉菜单后面。

通常情况下 模态框要放在网页内容最后 body关闭标签之前。大多数构建模态框的javascript库会自动这样做。 因为模态框使用固定定位 所以不必关心它的标记出现在哪里。它一定会定位到屏幕中间。 改变固定定位元素的标记位置不会产生不好的影响。但是对相对定位或绝对定位的元素来说，通常无法用改变标记位置的方法解决层叠问题。相对定位依赖于文档流，绝对定位元素依赖于它的定位祖先节点，这时候需要用z-index属性来控制它们的层叠行为。

用z-index控制层叠顺序 z-index属性的值可以是任意整数（正负都行） z表示的是笛卡尔xyz坐标系里的深度方向。拥有较高z-index的元素出现在拥有较低z-index的元素前面。拥有负数z-index的元素出现在静态元素后面。 使用z-index是解决网页层叠问题的第二个方法。该方法不要求修改HTML的结构。将modal-backdrop的z-index设置为1，将modal-body的z-index设置为2，确保模态框的主体在蒙层前面。代码78*/

/*
.modal-backdrop {
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	background-color: rgba(0,0,0,0.5);
	z-index: 1;
}

.modal-body {
	position: fixed;
	top: 3em;
	bottom: 3em;
	right: 20%;
	left: 20%;
	padding: 2em 3em;
	background-color: white;
	overflow: auto;
	z-index: 2;
}
*/

/*z-index:1 将模态框的蒙层拉到没有设置z-index的元素前面，：2 将模态框主体拉到蒙层前面 z-index的行为很好理解，但是使用它时要注意两个小陷阱。第一 z-index只在定位元素上生效，不能用它控制静态元素。第二 给一个定位元素加上z-index可以创建层叠上下文。 */

/*代码7-9css 这里面大部分代码是给盒子大小和颜色，以便看清层叠顺序 另外用负的外边距让元素重叠 而最核心的代码是给每个元素加上position和z-index*/

/*
body {
	margin: 40px;
}

.box {
	display: inline-block;
	width: 200px;
	line-height: 200px;
	text-align: center;
	border: 2px solid black;
	background-color: #EEAA55;
	margin-left: -60px;
	vertical-align: top;
}

.one { margin-left:0;}
.two {
	margin-top: 30px;
}
.three {
	margin-top: 60px;
}

.positioned {
	position: relative;
	background-color: #55AAEE;
	z-index: 1;
}

.absolute {
	position: absolute;
	top: 1em;
	right: 1em;
	height: 2em;
	background-color: #FFFFFF;
	border: 2px dashed #888;
	z-index: 100;
	line-height: initial;
	padding: 1em;
}
*/

/*叠放在第二个盒子后面的第一个盒子是一个层叠上下文的根。因此 虽然它的z-index值很高，但是它内部的绝对定位元素不会跑到第二个盒子前面。 给一个定位元素加上z-index是创建层叠上下文最主要的方式，但还有别的属性也能创建，比如小于1的opacity属性，还有transform/ filter属性。由于这些属性主要会影响元素及其子元素渲染方式 因此一起绘制父子元素。文档根节点 html 也会给整个页面创建一个顶级的层叠上下文。

所以层叠上下文内的元素会按照以下顺序 从后到前层叠放

层叠上下文的根， z-index为负的定位元素 及其子元素， 非定位元素， z-index为auto的定位元素 及其子元素， z-index为正的定位元素 及其子元素。*/

/*粘性定位 7-12 */

/*
.container {
	display: flex;
	width: 80%;
	max-width: 1000px;
	margin: 1em auto;
	min-height: 100vh;
}

.col-main {
	flex: 1 80%;
}

.col-sidebar {
	flex: 20%;
}

.affix {
	position: sticky;
	top: 1em;
}*/

/*响应式布局网页样式*/

/*
:root {
	box-sizing: border-box;
	font-size: calc(1vw + 0.6em);
}

*::before,
*::after {
	box-sizing: inherit;
}

body {
	margin: 0;
	font-family: helvetica, arial, sans-serif;
}

a:link {
	color:#1476b8;
	font-weight: bold;
	text-decoration: none;
}

a:visited {
	color:#1430b8;
}

a:hover {
	text-decoration: underline;
}

a:active {
	color: #b81414;
}

.page-header {
	padding: 0.4em 1em;
	background-color: #fff;
}

.title > h1 {
	color: #333;
	text-transform: uppercase;
	font-size: 1.5rem;
	margin: 0.2em 0;
}

.slogan {
	color: #888888;
	font-size: 0.875em;
	margin: 0;
}

.hero {
	padding: 2em 1em;
	text-align: center;
	background-image: url(conffee-beans.jpg);
	background-size: 100%;
	color: #fff;
	text-shadow: 0.1em 0.1em 0.3em #000;
}

main {
	padding: 1em;
}

.subtitle {
	margin-top: 1.5em;
	margin-bottom: 1.5em;
	font-size: 0.875rem;
	text-transform: uppercase;
}
*/

/*将网页标题和副标题设置为全大写，还给页面上各种组件加上了外边距 调整字号。主图里 text-shadow属性的几个值最终会构成文字下面的投影。前两个值是笛卡尔坐标，表面了投影相对于文字位置的偏移量。0.1em 0.1em 表示投影相对于文字稍微往右下偏移。第三个值 0.3em表示投影模糊的程度 #000定义投影颜色*/

/*8.1移动优先  <nav>作为一个兄弟元素出现在<header>后面，这意味着它会流动到头部下面的空间。为了实现设计效果，这里需要进行一项不常用的操作，使用绝对定位将菜单切换到按钮上面，让它出现在头部元素里面。*/

/*
.menu {
	position: relative;
}
*/
/*给两个绝对定位的子模块创建包含块*/
/*
.menu-toggle {
	position: absolute;
	top: -1.2em;
	right: 0.1em;
	border: 0;
	background-color: transparent;
	font-size: 3em;
	width: 1em;
	height: 1em;
	line-height: 0.4;
	text-indent: 5em;
	white-space: nowrap;
	overflow: hidden;
}
负的top值将按钮拉到了包含块的上面；覆盖浏览器的按钮样式；隐藏按钮的文本内容，将它的大小固定成1em
.menu-toggle::after {
	position: absolute;
	top: 0.2em;
	left: 0.2em;
	display: block;
	content: *\2261*;
	text-indent: 0;

}*/
/*用一个表示汉堡包图标的Unicode符号将按钮覆盖*/
/*
.menu-dropdown {
	display: none;
	position: absolute;
	right: 0;
	left: 0;
	margin: 0;
}

.menu.is-open .menu-dropdown {
	display: block;
}
*/

/*相对定位的菜单容器为它的两个子元素--切换按钮和下拉菜单--创建了包含块。负的top值将切换按钮向上拉了一段，right属性将它定位在屏幕右侧。最后切换按钮就位于网页标题右侧的头部区域了。
在按钮上用一些替换的 小把戏，限制它的宽度 加上较大的文字缩进，并且将overflow设置成 hidden 从而隐藏了按钮本身的文字（“toggle menu").然后给按钮的::after伪元素加上一个unicode字符(\2261) 作为内容。三条横线表示汉堡菜单
使用类is-open时，最后的选择器(.menu.is-opem.menu-dropdown)就会选中下拉菜单，没有这个类时 就不会选中下拉菜单。
8-4 用javascript会在按下切换按钮的时候添加和删除类is-open 放在</body>标签前 这种方式通过点击 点击 来打开关闭下拉菜单，css会负责显示和隐藏指定元素，JavaScript只需要负责改变一个类。
再给nav-menu添加一些样式。
*/

/*
.nav-menu {
	margin: 0;
	padding-left: 0;
	border: 1px solid #ccc;
	list-style: none;
	background-color: #000000;
	color: #FFFFFF;
}

.nav-menu > li + li {
	border-top: 1px solid #ccc;
}
给每个菜单元素加上边框
.nav-menu > li > a {
	display: block;
	padding: 0.8em 1em;
	color: #fff;
	font-weight: normal;
}
*/

/*使用适当的内边距确保有足够大的点击区域。*/

/*媒体查询 允许某些样式只在页面满足特定条件才生效。这样就可以根据屏幕大小定制样式*/

/*
@media (min-width: 560px) {
	.title > h1 {
		font-size: 2.25em;
	}
}*/

/*给网页标题样式增加断点*/

/*
.title > h1 {
	color: #333333;
	text-transform: uppercase;
	font-size: 1.5rem;
	margin: .2em 0;
}

@media (min-width: 35em) {
	.title > h1 {
		font-size: 2.25em;
	}
}
*/
/*现在根据视口大小 网页标题有两种不同的字号。当视口小于35em的时候是1.5rem,大于35em的时候是2.25rem. 通过缩放浏览器窗口就能测试标题样式。 当窗口很窄的时候，标题是适应移动端的小字号。慢慢放大浏览器窗口，字号会平滑地改变，因为网页设置了响应式(calc())字号。只要网页宽度达到35em 或者560px 标题的字号马上就会变成2.25rem. 在这里560px这个临界值被成为断点。 

媒体查询的类型 还可以进一步将两个条件用and关键字联合起来组成一个媒体查询。*/

/*@media (min-width: 20em) and (max-width: 35em) {...}*/

/*如果设备只需要满足多个条件之一，可以用逗号分隔*/
/*@media (max-width: 20em), (min-width: 35em;) {...}*/
/*
媒体特征
(min-height: 20em) 匹配高度大于等于20em的视口
(max-height: 20em) 匹配高度小于等于20em的视口
(orientation:landscape) 匹配宽度大于高度的视口。
(orientation:portrait) 匹配高度大于宽度的视口。*/
/*(min-resolution:2dppx) 匹配屏幕分辨率大于等于2dppx的设备，dppx指每个css像素里包含的物理像素点数。

(max-resolution:2dppx) 匹配屏幕分辨率小于等于2dppx的设备。

兼容浏览器的设置

@media (-webkit-min-device-pixel-ratio:2), (min-resolution: 192dpi) (...) 有些浏览器不支持dppx单位，因为需要使用dpi（每英寸的像素点数）单位代替例如：192dpi代替2dpx.

最后一个媒体查询的选项是媒体类型。常见的两种媒体类型是screen和print 使用print媒体查询可以控制打印时的网页布局，这样就能在打印时去掉背景 节省墨水。隐藏不必要的导航栏。 针对打印样式，使用@media print查询语句 不需要像min-width或者其他媒体特征那样加小括号。同理，针对屏幕样式，使用@media screen.

考虑打印样式 开发CSS的时候，通常在事后才会处理打印样式，而且只在需要的时候才会去考虑，但还是有必要思考用户是否想要打印网页的。 大多数情况下，需要将基础打印样式放在@media print {...}媒体查询内。

使用display:none隐藏不重要的内容，比如导航菜单和页脚。当用户打印网页时，他们绝大多数情况下只关心网页主体。
还可以将整体的字体颜色设置成黑色，去掉文字后面的背景图片和背景颜色。大多数情况下，用通用选择器就能实现。 
*/
/*
@media print {
	* {
		color: black !important;
		background: none !important;
	}
}*/
/*使用!important 防止规则被覆盖*/
/*给网页添加断点 移动优先的开发方式意味着最常用的媒体查询类型应该是min-width.在任何媒体查询之前，最先写的是移动端样式，然后设置越来越大的断点。8-8*/

/*
.title {
	...
}

@media (min-width: 35em) {
	.title {
		...
	}
}

@media (min-width:50em) {
	.title {
		...
	}
}
*/

/*中等屏幕的断点：覆盖对应的移动端样式，大屏幕断点：覆盖对应的小屏幕和中等屏幕断点的样式*/

/*中等屏幕断电下的内边距和字体调整*/
/*
.page-header {
	padding: 0.4em 1em;
	background-color: #fff;
}

@media (min-width: 35em) {
	.page-header {
		padding: 1em;
	}
}

.hero {
	padding: 2em 1em;
	text-align: center;
	background-image: url(coffee-beans.jpg);
	background-size: 100%;
	color: #FFFFFF;
	text-shadow: 0.1em 0.1em 0.3em #000;
}

@media (min-width: 35em) {
	.hero {
		padding: 5em 3em;
		font-size: 1.2rem;
	}
}

main {
	padding: 1em;
}

@media (min-width: 35em) {
	main {
		padding: 2em 1em;
	}
}
*/
/*总是确保每个媒体都位于它要覆盖的样式之后，这样媒体查询内的样式就会有更高的优先级。接下来处理菜单样式，菜单将涉及两处变化：首先 要将下拉菜单的打开和关闭行为去掉，这样才能始终保持可见。其次 要将菜单从垂直排列改为水平排列布局。这两处改变将一起实现*/

/*为中等屏幕断点重构导航菜单。*/
/*
@media (min-width: 35em) {
	.menu-toggle {
		display: none;
	}
	.menu-dropdown {
		display: block;
		position: static;
	}
}

@media (min-width: 35em) {
	.nav-menu {
		display: flex;
		border: 0;
		padding: 0 1em;
	}
	.nav-menu > li {
		flex: 1;
	}
	.nav-menu > li + li {
		border: 0;
	}
	.nav-menu > li > a {
		padding: 0.3em;
		text-align: center;
	}
}*/

/*最后一步是要为中等屏幕断点引入多列布局。 只需要将这些样式封装在一个媒体查询里，这样就不会影响到小于这个断点的屏幕设备 写标记的时候，给想要加上三列布局的地方加上row和column类。接下来定义相关样式。*/
/*
@media (min-width: 35em) {
	.row {
		display: flex;
		margin-left: -.75em;
		margin-right: -.75em;
	}
	
	.column {
		flex: 1;
		margin-left: 0.75em;
		margin-right: 0.75em;
	}
}
*/

/*
@media (min-width: 50em) {
	.page-header {
		padding: 1em 4em;
	}
}

@media (min-width: 50em) {
	.hero {
		padding:7em 6em;
	}
}

@media (min-width: 50em) {
	main {
		padding:2em 4em;
	}
}

@media (min-width: 50em) {
	.nav-menu {
		padding:0 4em;
	}
}
*/

/*还需要最后一点调整。现在根元素的响应式字号为font-size: calc(1vm + 0.6em), 在大屏上就显得太大了。可以在最大的断点处给字号加一个上限。*/
/*
:root {
	box-sizing: border-box;
	font-size: calc(1vw + 0.6em);
}

@media (min-width: 50em) {
	:root {
		font-size: 1.125em;
	}
}
*/

/*--这个布局由<table> 、<tr>、 <td>元素组成，但是我们对它们使用了display:block声明，覆盖了正常的table、table-row| table-cell的显示值。可以用max-width媒体查询限制在小屏下才改变表格元素的显示。可以将代码应用到任意<table>标签查看效果。
在移动设备上实现表格的响应式布局*/
/*

table {
	width: 100%;
}

@media (max-width: 30em) {
	table, thead, tbody, tr, th, td {
		display: block;
	}
	
	thead tr {
		position: absolute;
		top: -9999px;
		left: -9999px;
	}
	
	tr {
		margin-bottom: 1em;
	}
	
}
*/

/*以上样式让每个单元格从上到下排列，并且在每个<tr>之间添加了外边距，但是这样会让<thead>行不再跟下面的每一列对齐，因此要用绝对定位将头部移出视口。出于可访问性的缘故，我们没有用display:none, 这样屏幕阅读器能够读到表头。虽然不是完美的解决办法，但是当其他方式失效的时候，这就是最好的方式。*/

/*要避免不必要的高分辨率图片，而是否必要则取决于视口大小。也没有必要为小屏幕提高大图，因为大图最终会被缩小。响应式图片的最佳实践是为一个图片创建不同分辨率的副本。如果用媒体查询能够知道屏幕的大小，就不必发送过大的图片，不然浏览器为了适配图片也会将其缩小 使用响应式技术给不同屏幕尺寸提高最合适的图片。*/

/*
@media (min-width: 35em) {
	.hero {
		padding: 5em 3em;
		font-size: 1.2rem;
		background-image: url(coffee0beans-medium.jpg);
	}
}

@media (min-width: 50em) {
	.hero {
		padding: 7em 6em;
		background-image: url(coffee-beans.jpg);
	}
}
*/

/*使用srcset提供对应的图片 媒体查询能够解决用CSS加载图片的问题，但是HTML里的<img>标签 这种行内图片 有另一个重要解决办法：srcset属性 （"source set"的缩写）它可以为一个<img>标签指定不同的图片URL, 并指定相应的分辨率。浏览器会根据自身需要决定加载哪个图片。code8-16*/
/*
<img alt="a white coffee mug on a bed of coffee beans." src="coffee-beans-small.jpg" srcset="coffee-beans-small.jpg 560w,
coffee-beans-medium.jpg 800w,
coffee-beans.jpg 1280w" />*/
/*两手准备，给不支持srcset的浏览器提供常规的src属性（ie, oprea mini)。 每个图片的URL指定宽度。图片作为流式布局的一部分，要确保它不会超过容器的宽度。办法是在样式表加入规则 img {max-width: 100%;}*/

/*
模块化样式。
每个样式表的开头都要写一些给整个页面使用的通用规则，模块化css也不例外 称为基础样式 code-9-1。*/
:root {
	box-sizing: border-box;
}

*,
*::before,
*::after {
	box-sizing: inherit;
}

body {
	font-family: Helvetica, arial, sans-serif;
}

/*其他常用的基础样式还包括链接的颜色 标题的样式 外边距等。<body>标签默认的外边距很小，你可能会考虑将它的外边距去掉。推荐一个normalize.css库，这个小样式表可以协助消除不同的客户端浏览器渲染器渲染上的不一致。可以从https://necolas.github.io/normalize.css/下载该库，然后添加到自己的样式表前面作为基础样式的一部分。*/

/*一个简单模块-短消息通知模块 902*/
.message {
	padding: 0.8em 1.2em;
	border-radius: 0.2em;
	border: 1px solid #265559;
	color: #265559;
	background-color: #E0F0F2;
}

/*模块的选择器由单个类名构成，这非常重要。选择器里没有其他规则来约束这些样式仅作用在页面上的某个地方。如果使用一个类似#sidebar.message的选择器，就意味着这个模块只能用在#sidebar元素内部。没有这些约束，模块就可以在任意上下文中重复使用。
通过给元素添加类名，就可以把这些样式复用到很多场景，比如针对表单输入给用户反馈，提供醒目的帮助文字，或者提醒用户注意免责声明条款等。使用相同的组件就产生了一套风格一致的UI。所有用到组件的地方将看上去一样，不会出现有的地方蓝绿色有色差 有的地方内边距偏大等问题。*/

/*通过定义修饰符来实现不同的模块变体*/
/*新建三个修饰符 成功，警告，错误 通常使用两个连字符来表示修饰符 message--error code9-5*/
.message{
	padding: 0.8em 1.2em;
	border-radius: 0.2em;
	border: 1px solid #265559;
	color: #265559;
	background-color: #E0F0F2;
}
.message--success {
	color: #2f5926;
	border-color: #2f5926;
	background-color: #cfe8c9;
}

.message--warning {
	color: 594826;
	border-color: #594826;
	background-color: #cfe8c9;
}
.message--error {
	color: #59262F;
	border-color: #59262f;
	background-color: #e8c9cf;
}

/*修饰符的样式不需要重新定义整个模块，只需要覆盖改变的部分。*/

/* 创建带一些变体的模块。实现一个按钮模块，其中包含大小和颜色选项的变体 code 9-7*/

.button {
	padding: 0.5em 0.8em;
	border: 1px solid #265559;
	border-radius: 0.2em;
	background-color: transparent;
	font-size: 1rem;
}

.button--success {
	border-color: #cfe8c9;
	color: #fff;
	background-color: #2f5926;
}

.button--danger {
	border-color: #e8c9cf;
	color: #fff;
	background-color: #a02323;
}

.button-small {
	font-size: 0.8rem;
}

.button--large {
	font-size: 1.2rem;
}

/* 这里尺寸修饰符 small large 能够设置字体的大小。通过更改字号来调整元素相对单位的大小，进而改变内边距和边框圆角的大小，而不需要重写已经定义好的值 */

/* 不要使用依赖语境的选择器。假如我们正在维护一个网站，里面有浅色调的下拉菜单，有一天需要改成带白色文本的深色调。如果没有模块化CSS 我们可能会使用类似于，page-header.dropdown的选择器，先选中要修改的下拉菜单，然后通过选择器写一些样式，覆盖dropdown类提供的默认颜色。现在要写模块化CSS 这样的选择器是严格禁用的。虽然使用后代选择器可以满足当下的需要，但接下来可能会带来很多问题。
1 我们必须考虑把这段代码放在哪里，和网页头部的样式放在一起还是跟下拉菜单的样式放在一起。如果我们添加太多类似的单一目的规则，样式之间毫无关联，到最后样式表会变得杂乱无章
2 这种做法提升了选择器优先级 当下次需要修改代码的时候 我们需要满足或者继续提升优先级
3 后面我们可能需要在其他场景用到深色的下拉列表。刚才创建的这个下拉列表是限定在网页头部使用。如果侧边栏也需要同意的下拉列表，我们就得为该规则集添加新的选择器来匹配两个场景，或者完整地复制一遍样式。 
4 重复使用这种写法会产生越来越长的选择器，将CSS跟特定的HTML结构绑定在一起。例如 如果有个#products-page.sider .social-media div:first-child h3 这样的选择器 样式集就会和指定页面的指定位置紧紧耦合

当模块需要有不同的外观或者表现的时候，就创建一个可以直接应用到指定元素的修饰符类 比如写.dropdown--dark 而不是写成.page-header .dropdown.通过这种方式，模块本身 并且只能是它本身 可以决定自己的样式表现 其他模块不能进入别的模块内部去修改它 这样 深色下拉列表并没有绑定到深层嵌套的HTML结构上，也就可以在页面上需要的地方随意使用。*/

/* 多元素模块 我们已经创建了消息和按钮两个模块 下面创建一个更复杂的模块，由4个元素组成: div容器 容器包含的一张图片和正文、正文里的标题。跟其他模块一样，我们会给主容器添加media类名来匹配模块名称。对于图片和正文，可以使用类名media_image和media_body 这些类名以模块名称开头，后跟双下划线 然后是子元素名称。(这是BEM命名规范里的另一种约定，就跟双连字符代表的修饰符一样。 
代码9-8*/
.media {
	padding: 1.5em;
	background-color: #eee;
	border-radius: 0.5em;
}

.media::after {
	content: " ";
	display: block;
	clear: both;
}

.media__image {
	float: left;
	margin-right: 1.5em;
}

.media__body {
	overflow: auto;
	margin-top: 0;
}

.media__body > h4 {
	margin-top: 0;
}
/* 图片是媒体模块的一个子元素，所以可以使用选择器.media > .media__image, 但这不是必要的。因为media__image类名包含了模块的名称，所以已经确保模块名称是独一无二的了。

正文标题确实直接使用了后代选择器。其实也可以用media__title类 (或者media__body_title,这样可以完整地表示出在整个层级中的位置。) 但是大部分时候没必要。本例中 <h4>标签已经足够语义化，能够表面这是媒体模块的标题。不过这样一来 标题就不能使用其他的HTML标签 h3或者h5了 如果这样限制过于严格，可以改成使用类名来匹配元素*/

/* 代码9-10 */
.media--right > .media__image {
	float: right;
}
/* 把右浮动添加到图片子元素，但是只在media--right 修饰符中生效这条规则覆盖了媒体图片之前的float:left,由于浮动的工作原理，不需要改变HTML中元素的排列顺序。 */
/* 避免在模块选择器中使用通用标签名。在媒体模块中使用了选择器.media__body > h4 来匹配标题元素。这么做是允许 ，因为<h4>标签就是用来标识一个次要标题的。同样的方式也可以用在带列表的模块上。相比为列表里的每个项目都添加menu__item类名，使用.menu > li匹配菜单项简单多了，尽管这种写法有些争议。
应该避免使用基于通用标签类型的匹配，比如div和span。类似于 .page-header > span的选择器太宽泛。最初建立模块的时候，可能只是用span标签做一件事，说不定有第二个。 */

/* 9.3拆分不同模块的职责 用两个不同的模块来创建下拉菜单。第一个模块称下拉 其中包含一个控制容器可见性的按钮。这个模块负责展示和隐藏容器。第二个模块叫作菜单，是放置链接的列表。把菜单模块的一个实例放入下拉模块的容器内，就可以构成完整的界面。这段代码主体是一个下拉模块，下拉模块内部包含菜单模块。代码中还有小段JAVASCRIPT 当触发器被点击时用来实现开关的功能。
code 9-11 
code9-12 下拉模块*/
.dropdown {
	display: inline-block;
	position: relative;
}

.dropdown__toggle {
	padding: 0.5em 2em 0.5em 1.5em;
	border: 1px solid #ccc;
	font-size: 1rem;
	background-color: #eee;
}

.dropdown__toggle::after {
	content: " ";
	position: absolute;
	right: 1em;
	top: 1em;
	border: 0.3em solid;
	border-color: black transparent transparent;
}

.dropdown__drawer {
	display: none;
	position: absolute;
	left: 0;
	top: 2.1em;
	min-width: 100%;
	background-color: #eee;
}

.dropdown.is-open .dropdown__toggle::after {
	top: 0.7em;
	border-color: transparent transparent black;
}

.dropdown.is-open .dropdown__drawer {
	display: block;
}
/* 这是第一个使用定位的模块，其中创建了模块自己的包含块(主元素的position:relative) 绝对定位的元素(抽屉元素和::after伪元素)就是基于同一个模块内的位置来定位的。
is-open类在下拉模块中有特定的用途。在模块使用javascript动态地添加或移除它。它也是状态类 stats class的一个示例，因为它代表着模块在当前状态的表现
按照惯例 状态类一般以is- has-开头，这样状态类的目的就会比较明显。它们表示模块当前状态下的一些特征或者即将发生的变化。举例 is-expanded is-loading has-error */

/* 预处理器和模块化CSS 所有预处理器 如Sass LESS都提供了把分散的CSS文件合并成一个文件的功能。可以用多个文件和多个目录来组织样式，最后提供一个文件给浏览器，这样可以减少浏览器发起的网络请求数，开发者也可以把代码文件拆分成易于维护的大小。
使用预处理器， 建议把CSS里的每个模块都放在各自对应命名的文件里，并按实际需要将这些文件组织到不同目录中。然后创建一个主样式表，引入所有的模块。这样一来，你想修改某个模块就不必到一个冗长的样式表里面搜索。
创建一个main.css文件，里面包含@import语句 如：
@import 'base';
@import 'message';
@import 'button';
@import 'media';
@import 'dropdown';
预处理器会从base.css 中引入基础样式，从每个模块文件引入相应的模块样式，然后输出一个包含所有样式的样式表文件。 */

/* 菜单模块 code9-13  */
.menu {
	margin: 0;
	padding-left: 0;
	list-style-type: none;
	border: 1px solid #999;
}

.menu > li + li {
	border-top: 1px solid #999;
}

.menu > li > a {
	display: block;
	padding: 0.5em 1.5em;
	background-color: #eee;
	color: #369;
	text-decoration: none;
}

.menu > li > a:hover {
	background-color: #fff;
}
/* 覆盖浏览器默认样式，移除列表的项目符号。每个链接之间添加一条边框 增大链接的可点击区域。给鼠标悬停添加高亮效果 每个<li>都是模块的子元素，所有没有必要为每个元素添加双下划线类，直接使用后代选择器.menu > li已经足够明确 */
/* 工具类，我们需要用一个类来对元素做一件简单明确的事，比如让文字居中，让元素左浮动，或者清除浮动。这样的类被称为工具类。code 9-14 四个小工具类 */
.text-center {
	text-align: center !important;
}

.float-left {
	float: left;
}

.clearfix::before,
.clearfix::after {
	content: " ";
	display: table;
}

.clearfix::after {
	clear: both;
}

.hidden {
	display: none !important;
}

/* 让容器内的文字居中 为元素设置左浮动 清除浮动 隐藏页面上某个元素
这里用到了两次!important 工具类是唯一应该使用important注释的地方。事实上 工具类应该优先使用它。不管在哪里用到工具类，都可以生效。 任何时候为元素添加text-center 类，都是想让文本居中，不想让其他样式覆盖它，important注释可以确保这一点。
可以把这些类添加到页面元素里看看实际效果。<div class="text-center">可以使其中的文本居中。将float-right添加到<img>标签可以使其浮动，把clearfix添加到<img>的容器元素上可以使其包裹浮动
*/
/*code 11-2*/
/*
.fade {
	height: 200px;
	width: 120px;
	background-image: linear-gradient(90deg, white, lightskyblue);
}*/

/*包含多个颜色节点的线性渐变*/
/*
.fade {
	height: 250px;
	width: 500px;
	background-image: linear-gradient(90deg, red, white, blue);
}
*/
/*最左侧从红色开始，过渡到中间白色，到最右侧蓝色，0% 50% 100% 位置比例加在颜色后面，默认值可不加。
条纹，如果在同一个位置设置两个颜色节点，那么渐变会直接从一个颜色变换到另一个，而不是平滑过渡。例子，从红色变成白色再变成蓝色 渐变和无渐变可以一起使用。*/
/*
.fade {
	height: 120px;
	width: 360px;
	background-image: linear-gradient(90deg,yellow 10%, red 30%, white 30%, white 66%, green 66%, green 80%, lightgrey 100%);
}
*/
/*重复渐变 函数repeating-linear-gradient()*/
/*
.fade {
	height: 5em;
	width: 360px;
	background-image: repeating-linear-gradient(120deg, blue, green 15px, white 15px, red 30px);
	border-radius: 0.3em;
}*/
/*使用径向渐变 线性渐变是从元素的一端开始，沿着直线过渡到另一端，而径向渐变不同。颜色 比例 各自设置*/
/*
.fade {
	height: 250px;
	width: 480px;
	background-image: radial-gradient(yellow 30%, white 30%, white 60%, pink 60%, pink 70%, lightblue 80%, lightblue);
}
*/
/*跟线性渐变一样，径向渐变同样支持颜色节点。可以提供多个节点，使用百分比或者长度单位指定节点位置。可以设置为圆形而非椭圆，可以指定渐变中心点位置。repeating-radial-gradient()函数可以重复生成图样，形成同心圆环。*/

/*
.fade1 {
	height: 200px;
	width: 600px;
	background-image: radial-gradient(white, midnightblue);
}

.fade2 {
	height: 200px;
	width: 600px;
	background-image: radial-gradient(circle, white, midnightblue);
}

.fade3 {
	height: 200px;
	width: 400px;
	background-image: radial-gradient(3em at 80% 80%, white, midnightblue);
}

.fade4 {
	height: 200px;
	width: 400px;
	background-image: radial-gradient(circle, midnightblue 0%, white 75%, red 100%);
}

.fade5 {
	height: 200px;
	width: 400px;
	background-image: repeating-radial-gradient(circle, midnightblue 0, midnightblue 1em, yellow 1em, white 2em)
}
*/
/*1基础渐变-椭圆，2圆形渐变，3大小为3em 中心点距离左侧和顶部边缘都为25%，4指定颜色节点位置的径向渐变， 5重复渐变生成条纹效果*/
/*11.2阴影
创建阴影的两个属性，box-shadow可以为元素盒子生成阴影，text-shadow可以为渲染后的文字生成阴影。
box-shadow:1em 1em black, 1em代表偏移量 先水平后垂直。如果都设置为0， 那么阴影直接渲染在元素下方，black是阴影颜色。
如果元素设置了border-radius 那么阴影相应地也会有圆角。
可选值：box-shadow:1em 1em 2px 3px green, 依次是水平偏移量，垂直便宜量，模糊半径，扩展半径，颜色，第三四项是可选。
模糊半径用来控制阴影边缘模糊区域大小，可以为阴影生成一个更加柔和，有点透明的边缘。扩展半径用来控制阴影的大小，设置为正值可以使阴影全方位变大，设为负值则会变小*/
/*11-10 由上至下的渐变可以使按钮产生弧形3D效果，阴影加强这种效果。另外 用:active伪类来创建另一种阴影效果，供按钮摁下的时候使用。*/
/*code118 按钮的标记*/
/* .button {
	padding: 1em;
	border: 0;
	font-size: 0.8rem;
	color: white;
	border-radius: 0.5em;
	background-image: linear-gradient(to bottom, #88d, #151);
	box-shadow: 0.1em 0.1em 0.5em #121;
}

.button:active {
	box-shadow: inset 0 0 0.5em #123,
				inset 0 0.5em 1em rgba(0, 0, 0, 0.5);
} */

/* background-image属性提供两个相似的蓝色组成的渐变。盒阴影偏移得不是很多，只向右和向下分别偏移了0.1em;模糊效果也比较温和，只有0.5em.阴影偏移的越大，就显得图片从网页上提起的越，立体感越强，盒阴影效果改变了。 
这里我们做了两件事，增加了一个inset关键字，用来替换之前的盒阴影。这样就可以使阴影出现在元素边框的内部，而非之前的外部。同时我们定义了不止一个阴影，用逗号分隔。通过这种方式可以添加多个阴影。
第一个内阴影(inset 000.5em #123) 偏移量为0，轻微模糊。这在元素的边缘内添加了一个阴影环。第二个阴影(inset 00.5em 1em rgba(0,0,0,0.5))在垂直方向有一点便宜这样就让按钮顶部的阴影延长了一些。RGBA颜色表示法定义了一个半透明的黑色
在chrome浏览器中点击按钮时，你会发现按钮周围环绕一个浅蓝色光圈，只是浏览器为按钮的:focus状态默认添加的轮廓线。可以通过设置.button:focus{outline:none;}来移除轮廓线。建议你在移除轮廓线的同时，添加一些其他特效来代替，这样当用户使用键盘导航的时候，就可以看到当前焦点状态在哪里

*/
/* 扁平化按钮设计 */
/* .button {
	padding: 1em;
	border: 0;
	color: white;
	background-color: #57b;
	font-size: 1rem;
	padding: 0.8em;
	box-shadow: 0 0.2em 0.2em rgba(0, 0, 0, 0.15);
}

.button:hover {
	background-color: #456ab6;

}
.button:active {
	background-color: #148;
} */

/* 这里的盒阴影有一些改变，只有垂直向上的偏移，这样就只有向下的阴影，跟之前看上去很自然的阴影角度不一样。同时使用了RGBA颜色表示法，其中红绿蓝都是0 alpha值是0.5.鼠标悬停和激活状态的外观也是扁平化的，只是把背景颜色变成了暗一点的蓝色。同时字号也增加一些，这是扁平化设计兴起以来的另一种流行趋势 */

/* 另一种类型扁平化按钮，按钮底部有个厚厚的边框，这让按钮看上去像一个3D立方体的前侧。实际上这条深色的线并不是什么border，而是不加模糊效果的box-shadow 这样阴影的边缘可以生成和边框圆角相同的圆弧。激活状态 按钮向下方移动了少量像素的距离，看上去像按钮陷进了页面里 如同被按下去一样。
code11-11 */
/* .button {
	padding: 0.8em;
	border: 0;
	font-size: 1rem;
	color: white;
	border-radius: 0.5em;
	background-color: #58b;
	box-shadow: 0 0.4em #148;
	text-shadow: 1px 1px #148;
}

.button:active {
	background-color: #456ab5;
	transform: translateY(0.1em);
	box-shadow: 0 0.3em #148;
} */
/* 改回了圆角效果，按钮下方添加了阴影(无模糊效果) 添加了细小的文本阴影，点击时 按钮下移，减小了阴影的大小，用来抵消按钮的位移。
这里的按钮以一种不同的方式使用box-shadow, 不是叠加一个模糊效果的阴影，而是保持阴影边缘清晰。这样看起来就像一个厚厚的底部边框，但是跟真正的边框还是有一些区别的，因为它的圆角的弧度可以完美贴合元素的边框圆角。

这里的文字也添加了阴影效果。文本阴影跟盒阴影很像，不同的地方就是只有渲染后的文字有阴影，而不是整个元素盒子。文本阴影的语法也基本上完全一样：水平偏移量 垂直偏移量 模糊半径(可选)和颜色。但文本阴影不支持inset关键字和扩展半径值。在这里 我们为文本添加了一个深蓝色的阴影，每个方向各偏移了1px.
激活状态下 我们也做了一些新的事情。我们使用了transform属性以及translateY()函数，使元素在屏幕上下移了0.1em.然后我们把盒阴影的垂直偏移量减少了同样的距离(从0.4em变为0.3em).这样一来，按下按钮时，按钮移动 但盒阴影不会动。*/

/* 11.3混合模式 不论是使用真正的图片还是渐变，元素一般只会使用一张背景图片。但某些情况下 你可能想要使用两张或者更多的背景图片，CSS是支持的。
background-image属性可以接受任意数量的值，相互之间以逗号分隔，
background-image: url(test.jpg), linear-gradient(to bottom, #58b, #146);
使用多个背景图片时，列表中排在前面的图片会渲染到排序靠后的图片上面。以上test.jpg会遮盖在线性渐变之上，渐变就会不可见。而如果我们使用两张背景图片，那么一般是希望第二张图片也可以透视显示。这是就可以使用混合模式(blend mode)
code1112混合背景的DIV*/
/* .blend {
	min-height: 400px;
	background-image: url(test.jpg), url(test.jpg);
	background-size: cover;
	background-repeat: no-repeat;
	background-position: -30vw, 30vw;
	background-blend-mode: multiply;
} */
/* 使用逗号隔开的两张背景图片，设置一个值，应用到两张背景图片上。为每张背景图片设置不同的初始位置，应用混合模式。

大部分背景相关的属性可以接受多个值，以逗号分隔。background-position就使用了两个值，第一个值会应用到第一个背景图片上，第二个值会应用到第二张背景图片上。background-size和background-repeat属性也可以接受多个值，但如果只设置一个值，就会应用到所用的背景图片上。这里使用了min-height属性，是为了确保元素不会显示成高度为0
background-size属性接受了两个特殊的关键字值，分别是cover,contain.使用cover值可以调整背景图片的大小，使其填满整个元素，这样会导致图片的边缘被裁切掉一部分；使用contain值可以保证整个背景图片可见，尽管这可能导致元素的一些地方不会被背景图片覆盖(就像 letterboxing效果)，该属性也可以接受长度值，用来明确设置背景图片的宽度和高度。*/

/* 11.3.1为图片着色 
background-blend-mode不仅仅合并多个背景图片，还会合并background-color.所以这些叠放的图层，最终都会被混合模式拼合在一起，因此我们可以把背景颜色设置为想要的色相，混合到图片中去 code1114*/
/* .blend {
	min-height: 300px;
	background-image: url(test.jpg);
	background-color: #148;
	background-size: cover;
	background-repeat: no-repeat;
	background-position: center;
	background-blend-mode: luminosity;
} */
/* 蓝色背景，使用明度混合模式 明度混合模式将前景层test.jpg的明度 与背景层-蓝色背景色图层的色相和饱和度混合。即最终完全使用背景色图层的颜色，但是明暗程度来自test图片。明度混合模式或其他几种类似的混合模式，最终渲染的结果取决于哪个图层在其他图层之上，背景色图层始终在最下层，其他背景图片叠放在背景色图层之上。

如果一个蓝色图层放在test图层上面而不是下面（使用渐变色来代替背景颜色），最终渲染结果就会不同。为了达到同样的效果，就需要使用颜色混合模式（颜色混合模式和明度混合模式恰好相反，使用前景色的色相和饱和度与背景色的明度来生产最终的结果色）*/

/* 五大类混合模式 变暗，变亮 对比 复合和比较

变暗 multiply 背景色越亮 背景色显示出来的越多；darken 选择两个颜色中较暗的那个；color-burn 加深背景色，增加对比度
变亮 screen 背景色越暗 背景色显示出来的越多；lighten 选择两个颜色中较亮的那个；color-dodge 加亮背景色，降低对比度
对比 overlay 对暗色使用multiply 对亮色使用screen 以增加对比度，对比效果较柔和；hard-light 大幅度增加对比度 有点像叠加，但是使用加强版的multiply or screen 对比效果明显；soft-light 有点类似于hard-light 但是使用burn/dodge 来代替multiply/screen.
复合 Hue 将上层颜色的色相混合到下层颜色上；saturation 将上层颜色的饱和度混合到下层颜色上； luminosity 将上层颜色的明度混合到下层颜色上；color 将上层颜色的色相和饱和度混合到下层颜色上；
比较 difference 从亮色中减去暗色；exclusion 类似于difference 但对比度稍弱。*/

/* 为图片添加纹理 code1115 */

/* .blend {
	min-height: 400px;
	background-image: url("wenli.png"), url("test.jpg");
	background-size: 200px, cover;
	background-repeat: repeat, no-repeat;
	background-position: center center;
	background-blend-mode: soft-light;
} */

/* 将纹理图片覆盖于主图片上 每200px 平铺一张纹理图片 使用柔光混合模式。 */

/* 使用融合混合模式 background-blend-mode属性可以实现多张图片的混合，但只能局限于元素的背景颜色或者背景图片使用。还有一个属性mix-blend-mode, 可以融合多个元素。这样不仅可以混合图片，还可以把元素的文本和边框与容器的背景图片混合在一起。 soft-light模式对于暗色系纹理图片效果很好，而hard-light和overlay模式更适用于亮色的纹理图片-如果纹理图片放在主图片下面则恰好相反。*/

/* 使用融合混合模式 background-blend-mode属性可以实现多张图片的混合，但只能局限于元素的背景颜色或者背景图片使用。还有一个属性mix-blend-mode 可以融合多个元素。这样不仅可以混合图片，还可以把元素的文本和边框与容器的背景图片混合在一起。使用融合混合模式，可以把标题显示在图片上方，但遮住的图片部分依旧可以显示出来。 
融合后的效果很有意思，文字看上去是透明的，就像红色通知栏被减掉一部分。这里我们使用了hard-light混合模式和中灰色文字颜色。对比混合模式在使用很亮或很暗的颜色是才会有更好的效果，这里的文字我们使用了中灰色#808080，背景图层显示出来之后没有太大变化。*/

/* code1117 融合混合 */
/* .blend {
	background-image: url('test.jpg');
	background-size: cover;
	background-position: center;
	padding: 5em 0 10em;
}

.blend > h1 {
	margin: 0;
	font-family: Arial, Helvetica, sans-serif;
	font-size: 6rem;
	text-align: center;
	mix-blend-mode: hard-light;
	background-color: #c33;
	color: #808080;
	border: 0.1em solid #ccc;
	border-width: 0.1em 0;
} */

/* code121添加基础样式和颜色的网页 */
/* html {
	--brand-green: #076448;
	--dark-green: #099268;
	--medium-green: #20c997;
	--text-color: #212529;
	--gray: #868e96;
	--light-gray: #f1f3f5;
	--extra-light-gray: #f8f9fa;
	--white: #fff;

	box-sizing: border-box;
	color: var(--text-color);
} */
/* 为每种颜色指定变量 */

html {
	--brand-green: hsl(162, 87%, 21%);
	--dark-green: hsl(162, 88%, 30%);
	--medium-green: hsl(162, 73%, 46%);
	--text-color: hsl(210, 11%, 15%);
	--gray: hsl(210, 7%, 56%);
	--light-gray: hsl(210, 17%, 95%);
	--extra-light-gray: hsl(210, 17%, 98%);
	--white: hsl(0, 0%, 100%);
	--red: hsl(342, 63%, 46%);
	box-sizing: border-box;
	color: var(--text-color);
}
/* 把样式表切换HSL颜色 添加一种红色作链接激活显示*/

*,
*::before
*::after {
	box-sizing: inherit;
}

/* body {
	margin: 0;
	font-family: Arial, Helvetica, sans-serif;
	line-height: 1.4;
	background-color: var(--extra-light-gray);
}

h1, h2, h3, h4{
	font-family: georgia, serif;
} */
/* 用到颜色的地方用变量代替 */

a {
	color: var(--medium-green);
}

a:visited {
	color: var(--brand-green);
}

a:hover {
	color: var(--brand-green);
}

a:active{
	color: var(--red);
}
/* 先为链接激活状态占位，后面需要改成红色  链接的激活状态不是默认显示的，所以这稍微有点麻烦。需要单击并停留在链接上才能出发激活，一旦松手又会变成绿色，可以使用开发工具强制激活链接。
按鼠标右键点击链接，在菜单中选择"检查"或者"查看元素",就可以打开开发者工具。 在Elements面板，右键点击<a>标签，在菜单中选择:active 这样就可以强制浏览器显示元素的激活样式。*/
/* 头部样式 */
.nav-container {
	background-color: var(--medium-green);
}

.nav-container__inner {
	display: flex;
	justify-content: space-between;
	max-width: 1080px;
	margin: 0 auto;
}
/* 将内容居中，限制最大宽度为1080px */

.home-link {
	color: var(--text-color);
	font-size: 1.6rem;
	font-family: georgia, serif;
	font-weight: bold;
	text-decoration: none;
}

.top-nav {
	display: flex;
	list-style-type: none;
}

.top-nav a {
	display: block;
	padding: 0.3em 1.25em;
	color: var(--white);
	background: var(--brand-green);
	text-decoration: none;
	border-radius: 3px;
}

.top-nav a:hover {
	background-color: var(--dark-green);
}

.top-nav__featured > a {
	color: var(--brand-green);
	background-color: var(--white);
}

.top-nav__featured > a:hover {
	color: var(--medium-green);
	background-color: var(--white);
}
/* 从顶部开始，分三个部分来进行：头部区域 主图区域和三栏主体部分。大部分工作可以复用前面章节技术。首先是头部以及导航条区域。这部分由三个模块组成，nav-container、home-link和top-nav。 
整个头部区域包裹了一个nav-container.使用了双容器的模式来使内部的元素居中。这样可以实现背景颜色一直延伸到页面边缘，而主体部分被限制了宽度。主体部分是一个弹性盒子容器，使用justify-content:space-between将内容置于两端：home-link在左侧，top-nav在右侧。top-nav也使用了弹性布局，这样其内部的所有链接都排成一行，同时链接的颜色使用了自定义属性进行了配置。

接下来为主图区域添加样式。这部分包括两个模块，一个主图 另一个是按钮。code124*/
/* .hero {
	background: url(collaboration.jpg) no-repeat;
	background-size: cover;
	margin-bottom: 2.5rem;
}

.hero__inner {
	max-width: 1080px;
	margin: 0 auto;
	padding: 50px 0 200px;
	text-align: right;
}

.hero h2 {
	font-size: 1.95rem;
}

.button {
	display: inline-block;
	padding: 0.4em 1em;
	color: var(--brand-green);
	border: 2px solid var(--brand-green);
	border-radius: 0.2em;
	text-decoration: none;
	font-size: 1rem;
}

.button:hover {
	background-color: var(--dark-green);
	color: var(--white);
}

.button--cta {
	padding: 0.6em 1em;
	background-color: var(--brand-green);
	color: var(--white);
	border: none;
} */

/* 双容器模式，简单使用内边距定位标语和按钮，标准按钮样式 CTA 

像头部一样，主图区域使用了双容器模式。内容器设置了一些内边距，这里的内边距值只是粗略地估算的。还定义了一个按钮模块，默认的外观是白色按钮，带有绿色的边框和文字。页面的主体部分底部使用的按钮就是默认样式。然后我们还为按钮定义了一个CTA变体，使用纯绿色背景和白色文字。cta - call to action 

页面主区域的大概样式 几部分组成 限制了最大宽度的容器 控制三栏布局的tile-row和每一栏内的白色板块区域tile.*/

.container {
	margin: 0 auto;
	max-width: 1080px;
}

.tile-row {
	display: flex;
}

.tile-row > * {
	flex: 1;
}

.tile {
	background-color: var(--white);
	border-radius: 0.3em;
}

.page-footer {
	margin-top: 3em;
	padding: 1em 0;
	background-color: var(--light-gray);
	color: var(--gray);
}

.page-footer__inner {
	margin: 0 auto;
	max-width: 1080px;
	text-align: center;
	font-size: 0.8rem;
}

/* 页面最大宽度设置一致 1080px 使所有栏等宽 和页面其他部分一样 设置最大宽度1080px */

/* web内容无障碍指南WCAG提供了关于对比度最小值的建议。WCAG定义的大号文本，是指未加粗的18pt=24px及其以上的文本，或者加粗的14pt-18.667px及其以上的文本。正文字体应该达到或者超出普通文本建议的对比度，标题文本应该达到或者超出大号文本建议的对比度。
使用contrast ratio工具可以检查支持所有可用的CSS颜色格式。把背景颜色和文本颜色粘进去，就可以显示计算好的对比度 鼠标悬停在数字上，就可以查看其是否通过了WCAG的哪种字号AA/AAA级。
在设计规范中，导航条里的标注测量值显示菜单项需要10px的环绕间距。因为基础字号是16px 计算一下，使用期望长度除以基础字号，10除以16=0.625 所以这里的间距就是0.625em code128 使用内边距和外边距设置导航区域的间距*/

.nav-container {
	background-color: var(--medium-green);
}

.nav-container__inner {
	display: flex;
	justify-content: space-between;
	max-width: 1080px;
	margin: 0 auto;
	padding: 0.625em 0;
}

.top-nav {
	display: flex;
	list-style-type: none;
	margin: 0;
}

.top-nav > li + li {
	margin-left: 0.625em;
}

/* 为整个导航条的顶部和底部添加10PX的内边距，移除用户代理样式表为列表默认添加的外边距，每个导航项之间添加10px的水平外边距
在这个例子中，nav-container__inner应该用内边距来设置垂直间隔，这样就可以应用整个容器，最左侧的页面标题和顶部导航列表都可以填充间距。然后使用外边距来设置每个导航项之间的水平间隔，因为希望每项之间有间隔
主图下方和三栏之间，因为这些间隔都是应用于元素外部，不论带背景图片的元素还是设置背景色的元素，所以需要使用外边距来实现间隔。
主图下方40px 栏目之间25px的外边距  再次使用像素值除以基础字号，把长度转化为em。主图下方的40px相当于2.5em 每个栏目之间的25px相当于1.5625em code129 为主图下方和栏目之间添加外边距*/
/* .hero {
	background: url(test.jpg) no-repeat;
	background-size: cover;
	margin-bottom: 2.5rem;
}

.tile-row {
	display: flex;
}

.tile-row > * {
	flex: 1;
}

.tile-row > * + * {
	margin-left: 1.5625em;
} */

/* 确保主图下方有40PX的间距，每个栏目之间添加25px的间距 
code1210 设置板块和段落间距*/

p {
	margin-top: 1.5em;
	margin-bottom: 1.5em;
}

.tile {
	background-color: var(--white);
	border-radius: 0.3em;
	padding: 1.5625em;
}

.tile > h4 {
	margin-bottom: 1.5em;
}

/* 在基础样式中为段落添加外边距，在板块内部增加内边距，在板块标题下方添加外边距 
已经在基础样式中为段落设置1.5em的外边距，整个网页所有的段落都会有同样的间距。然后在板块标题下方设置一样的距离（.tile > h4)，因此不管后面有没有段落 标题下方的间距都会一直相同。这是由于存在外边距折叠，两个外边距会重叠，在标题和段落之间生成一个30px的间距。
标语的行高一样会影响到设置这些间距，因为它的字号更大。标语字号是1.95rem，这就意味着乘以16px的基础字号之后，字号是31.2px。然后再乘以1.4倍的行高，最终算出行高是43.68px，文字的上方和下方各有大约6px.
既然行高已经在文字上方占据了6px，我们只需要再增加89px的间隔，就达到了期望的95px.标语下方只需要再增加10px，就达到了视觉稿中显示的16px间隔。接下来就是把这些值转化为相对单位并添加到样式表。89/16=5.5625em 10/16得到0.625em.
code1211
*/

.hero {
	background: url(test.jpg) no-repeat;
	background-size: cover;
	margin-bottom: 2.5rem;
}

.hero__inner {
	max-width: 1080px;
	margin: 0 auto;
	padding: 5.5625em 12.5em 12.5em 0;
	text-align: right;
}

.hero h2 {
	font-size: 1.95rem;
	margin-top: 0;
	margin-bottom: 0.625rem;
}

/* 使用刚刚计算得到的距离替换之前的估值 移除上方的外边距，因为hero__inner的内边距已经提供了所需的间距 设置标语和按钮之间的间距 
hero__inner元素的顶部内边距设置了标语上方所需的间距。虽然设计稿中没有指定它的右侧和底部内边距，但我们也设置了值。标语的顶部外边距设置为0，这样就不会在hero__inner的内边距上再增加额外的距离。标语的底部外边距使用rem单位而不是em单位，这是因为标语不是使用默认的16px字号*/

/* 1220 列表项需要添加样式并实现行内显示 每项都需要设置display:inline,还需要少许的内边距 背景颜色和边框圆角。开始时感觉设置这些样式就够了，但是一旦内容出现折行，就暴露了问题。如果视口的宽度是固定值或者内容持续增加 排版就会被打乱。每一行列表项的灰色背景会和另一行的列表项重叠，原因在于行高。文本行的高度是有行高乘以字号决定，如果为行内元素添加内边距 元素本身会变高 却不会增加文本行的高度，文本行的高度只由行高来决定。  要解决整个问题 就需要增加每项的行高。
code1212为标签添加样式*/
.tag-list {
	list-style: none;
	padding-left: 0;
}

.tag-list > li {
	display: inline;
	padding: 0.3rem 0.5rem;
	font-size: 0.8rem;
	border-radius: 0.2rem;
	background-color: var(--light-gray);
	line-height: 2.6;
}

/* 覆盖用户代理默认的列表样式， 设置很大的行高，折行的时候增加垂直间距 只有行内元素有这种行为，如果一个元素是弹性子元素，为了容纳它 其所在的行会随之增高  只有行内元素有这种行为，如果一个元素是弹性子元素或者行内块级元素，为了容纳它，其所在的行会随之增高。还需要设置水平和垂直外边距，为子元素之间增加间隔。利用原本就有的白色背景，这些元素之间就产生了想要的间距*/

/* code13-2 使用web字体，google font */

body {
	margin: 0;
	font-family: roboto, sans-serif;
	line-height: 1.4;
	background-color: var(--extra-light-gray);
}

h1, h2, h3, h4 {
	font-family: Sansita, serif;
}

.home-link {
	color: var(--text-color);
	font-size: 1.6rem;
	font-family: Sansita, serif;
	font-weight: bold;
	text-decoration: none;
}

/* 对页面全局应用Roboto字体 设置标题为Sansita字体 设置首页链接为Sansita字体 */